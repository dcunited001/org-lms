#+PROPERTY: header-args    :tangle org-lms.el
#+ORG_LMS_COURSE: wildwater
I'm moving this package to a literate programming format to make it easier to maintain.

Source blocks are tangled using org-babel.  
* Package intro

#+begin_src emacs-lisp
  ;;; org-lms -- Summary
  ;;;
  ;;; Commentary:
  ;;; Library to facilitate marking assignments and interacting
  ;;; with the Canvas LMS (https://canvas.instructure.com/) via its
  ;;; JSON API (https://canvas.instructure.com/doc/api/).
  ;;;
  ;;; Functionality is still rough and design is idiosyncratic. I hope to
  ;;; one day design a more robusti nterface but... who know? 

  ;;; Code:


#+end_src

* What does this package contain? 

#+begin_src emacs-lisp :results list :tangle no
(matches-in-buffer "(\\\(defun .*\\\)")

#+end_src

#+RESULTS:
* Dependencies
#+begin_src emacs-lisp
;; require the dependencies
(require 'org) ;; the source of all good!
(require 'org-attach) ;; for attaching files to emails
(require 'cl) ;; may not be necessary anymore in newer Emacsen
(require 'org-mime) 
;;(require 'ov) ;; for grade overlays

#+end_src

* Define obsolete functions
THere's some stuff I should get rid of. Trying to track it down.  

#+begin_src emacs-lisp
  (define-obsolete-function-alias 'org-lms-send-subtree-with-attachments
    'org-lms~send-subtree-with-attachments)
(define-obsolete-function-alias 'org-lms-mail-all-undone 
    'org-lms-mail-all)
#+end_src
* ACTION Variable definitions
The underlying data structure has changed a bit :-) as I start to understand what information needs to be stored in non-textual data structures and what doesn't. A lot of this has not been documented yet!
  
- need to give a better default value to org-lms-courses

#+begin_src emacs-lisp
  ;; variables
  ;; most of these are used for canvas interactions...

  (defvar org-lms-courses nil
    "Alist in which each car is a symbol, and each cdr is a plist.

  Value of this variable must be set beforeusing the library. The
  plist should include at least the following attributes in order
  to match the local definition with the courses on canvas:

  - `:coursnum' 
  - `:name'
  - `:semester'
  ")

  (defcustom org-lms-baseurl nil
    "Baseurl for canvas API queries. 
    Should have the form \"https://canvas.instance.at.school/api/v1/\"."
    :type '(string)
    )

  (defcustom org-lms-token nil
    "Secret oauth token for Canvas. DO NOT SHARE THIS INFO.
    Probably customize is a rotten place to put this!"
    :type '(string))

  (defvar-local org-lms-course nil
    "Locally-set variable representing the local course.")

  (defvar-local org-lms-local-assignments nil
    "List of assignments for the current course. 

    Intended to be updated automatically somehow, but for now just
    being set in grading page")

  (defvar-local org-lms-merged-assignments nil
    "Buffer-local plist of students in this course, merging cnavas and local info. 

    Intended to be set automatically. Should always be buffer-local")

  (defvar-local org-lms-local-students nil
    "Buffer-local plist of students in this course, using local csv file. 

    Intended to be set automatically. Should always be buffer-local")

  (defvar-local org-lms-merged-students nil
    "Buffer-local plist of students in this course, merging cnavas and local info. 

    Intended to be set automatically. Should always be buffer-local")
(defcustom ol-make-headings-final-hook nil
  "list of functions to run just after a heading has been created"
  :safe t)
#+end_src

* Set up Testing
Unit tests wil lbe defined throughout and just tangled to a different place! First we have to set up the environment. You'll need to set some of these values up yourself!

#+begin_src emacs-lisp :tangle org-lms-tests.el
  (setq-local default-assignments (org-lms-read-assignment-map
                                   "~/Wildwater/Assignments-ww1.org")
        default-courseid 64706
        default-students (org-lms-merge-student-lists))
#+end_src

* Helper functions
These functions do things like parse csv files, set up json properly, etc.  
** Debug Messages
I am unfortunately no past the stage of using debug messages :-/ 
#+begin_src emacs-lisp :tangle no
(debug-message (message )
(if plaplapla))
#+end_src
** ACTION Read global values of org file
Stolen from [[https://emacs.stackexchange.com/questions/21713/how-to-get-property-values-from-org-file-headers/21715#21715][stackexchange]] via [[https://github.com/zzamboni/dot-emacs/blob/master/init.org#publishing-to-leanpub][Diego Zamboni]], thee functions allow Emacs to see values of props set in the header. 

I need to figure out a setter -- these are just getters.  Something like :

~(insert (concat "#+" (upcase property )))~

 But first find the right place i n the buffer (??)
#+begin_src emacs-lisp
  (defun org-lms-global-props (&optional property buffer)
    "Get the plists of global org properties of current buffer."
    (unless property (setq property "PROPERTY"))
    (with-current-buffer (or buffer (current-buffer))
      (org-element-map (org-element-parse-buffer) 'keyword (lambda (el) (when (string-match property (org-element-property :key el)) el)))))

  (defun org-lms-global-prop-value (key)
    "Get global org property KEY of current buffer."
    (org-element-property :value (car (org-lms-global-props key))))
#+end_src

#+RESULTS:
: org-lms-global-prop-value

*TODO* no tests yet!!

** ACTION CSV Parsers
There are several of these here. The code is largely redundant and should be combined into one or two
#+begin_src emacs-lisp
  ;; Helper Functions

  ;; I'm using hte namespace `org-lms~' for these internal helper functions.
  ;; At some liater date should figure out and implement approved best
  ;; oractices. 

  ;; CSV Parsers
  ;; Student information (name, email, etc) is exported from excel or blackboard in the form
  ;; of a CSV file.  These two functions parse such files

  (defun org-lms~parse-csv-file (file)
    "Transforms FILE into a list.
   Each element of the returned value is itself a list
  containing all the elements from one line of the file.
  This fn was stolen from somewhere on the web, and assumes
  that the file ocntains no header line at the beginning"
    (interactive
     (list (read-file-name "CSV file: ")))
    (let ((buf (find-file-noselect file))
          (result nil))
      (with-current-buffer buf
        (goto-char (point-min))
        ;; (let ((header (buffer-substring-no-properties
        ;;              (line-beginning-position) (line-end-position))))
        ;;   (push ))
        (while (not (eobp))
          (let ((line (buffer-substring-no-properties
                       (line-beginning-position) (line-end-position))))
            ;; (let templist (split-string line ",")
            ;;      ;;(print templist)
            ;;      ;; (push (cons (car templist) (nth 1 templist) ) result)
            ;;      )
            (push (cons (nth 0 (split-string line ",")) (nth 1 (split-string line ","))) result)
            )
          (forward-line 1)))
      (reverse result)))

  (defun org-lms~parse-plist-symbol-csv-file (file)
    "Transforms csv FILE into a list of plists.
  Like `parse-csv-file' but each line of the original file is
  turned into a plist. Returns a list of plists. Column header
  strings are transformed into downcased single-word keys, e.g.
  \"First Name\" becomes \":firstname\". Assumes that the first
  line of the csv file is a header containing field names. Clumsily
  coded, but works."
    (interactive
     (list (read-file-name "CSV file: ")))
    (message "here i am w/ %s" file)
    (let (;; (buf (find-file-noselect file))
          (result nil))
      (with-temp-buffer
        (if (file-exists-p (expand-file-name file)) (insert-file-contents (expand-file-name file)))
        (goto-char (point-min))
        (let ((header-props
               (split-string  (buffer-substring-no-properties
                               (line-beginning-position) (line-end-position)) ","))
              )
         (message "CSV PARSER: headerprops ;; %s" (buffer-string))
          (while (not (eobp))
            (let ((line  (split-string (buffer-substring-no-properties
                                        (line-beginning-position) (line-end-position)) ","))
                  (count 0)
                  (new-plist '()))
              (while (< count (length line))
                (message "here in loop w count %s of " count (length line))
                (setq new-plist (plist-put new-plist
                                           (intern (concat ":"
                                                           (downcase
                                                            (replace-regexp-in-string "\"" ""
                                                                                      (replace-regexp-in-string
                                                                                       "[[:space:]]" ""
                                                                                       (nth count header-props))))))
                                           (if (not (equal (nth count line) "false"))
                                               (replace-regexp-in-string "\"" "" 
                                                                         (nth count line))
                                             "")))
                (setq count (1+ count)))
              (push  new-plist result)
              (forward-line 1))))
        ;; (message "PARSER: result -- %s" result)
        (cdr (reverse result)))))
  (defun org-lms~parse-plist-csv-file (file)
    "Transforms csv FILE into a list of plists.
  Like `parse-csv-file' but each line of the original file is turned 
  into a plist.  Returns a list of plists. Assumes that the first line
  of the csv file is a header containing field names.  Clumsily coded, 
  but works."
    (interactive
     (list (read-file-name "CSV file: ")))
    (let ((buf (find-file-noselect file))
          (result nil))
      (with-current-buffer buf
        (goto-char (point-min))
        (let ((header-props
               (split-string  (buffer-substring-no-properties
                               (line-beginning-position) (line-end-position)) ","))
              )
          ;; (message "CSV PARSER: headerprops ;; %s" header-props)
          (while (not (eobp))
            (let ((line  (split-string (buffer-substring-no-properties
                                        (line-beginning-position) (line-end-position)) ","))
                  (count 0)
                  (new-plist '()))
              (while (< count (length line))
                (setq new-plist (plist-put new-plist
                                           (intern
                                            (replace-regexp-in-string "\"" ""
                                                                      (replace-regexp-in-string
                                                                       "[[:space:]]" ""
                                                                       (nth count header-props))))
                                           (if (not (equal (nth count line) "false"))
                                               (replace-regexp-in-string "\"" "" 
                                                                         (nth count line))
                                             "")))
                (setq count (1+ count)))
              (push  new-plist result)
              (forward-line 1))))
        ;; (message "PARSER: result -- %s" result)
        (cdr (reverse result)))))
#+end_src

#+RESULTS:
: org-lms~parse-plist-csv-file

no tests yet!
** Miscellaneous Helper functions
- navigate org trees w/ ~org-lms-get-parent-headline
- execute plist-get but return empty string (~""~) )instead of ~nil~ when element is absent/nil.  

Neither of these is heavily-used and the latter can be safely replaced by ~(format "%s")~ :-/ 

- ol2ns -- isn't used as much as it could be, either use ocnsistently or remove! 

#+begin_src emacs-lisp
;; Element tree navigation
;; not sure but I don't think I use this anymore
;; also trying to avoid relying on parental properties
;; remove in future
(defun org-lms~get-parent-headline ()
  "Acquire the parent headline & return. Used by`org-lms-make-headlines' and `org-lms-attach'"
  (save-excursion
    (org-up-heading-safe)
    (nth 4 (org-heading-components))
    ;;(org-mark-subtree)
    ;;(re-search-backward  "^\\* ")
    ;;(nth 4 (org-heading-components))
    ))
(defun org-lms-safe-pget (list prop)

  (if (plist-get list prop)
       
      (plist-get list prop)
    ""))

(defun oln2s (num)
  (cond
   ((numberp num)
    (number-to-string num))
   ((stringp num )
    num)
   (num
    (format "%s" num))
   (t
    "")))

;;copied and modified from https://github.com/jorendorff/dotfiles/blob/master/.emacs
;; should be replaced by emacs-kv
(defun org-lms-plist-to-alist (ls)
  "Convert a plist to an alist. Primarily for old color-theme themes."
  (let ((result nil))
    (while ls
      (add-to-list 'result (cons (intern (substring  (symbol-name (car ls)) 1 )) (cadr ls)))
      (setq ls (cddr ls)))
    result))

#+end_src

** JSON helpers and wrappers
Intended to make it easier to read and write json according to the library's standards.
- ol-jsonwrapper :: macro to set ~json.el~ vars temporarily around a ~json-read~ call
- ol-write-json-plists :: either there's a bug or I'm not understanding something; without thissetting lists of plists were being interpreted wrong by json-encode.
-  :: 
#+begin_src emacs-lisp
;; number-to-string was driving me crazy 


(defmacro ol-jsonwrapper (fn &rest args)
  "Run FN with ARGS, but first set `json.el' vars to `org-lms' defaults.
Allows org-lms functions to easily parse json consistently. The org-lms
default values are:
`json-array-type': 'list
`json-object-type': 'plist
`json-false': nil
`json-key-type': 'keyword"
  
  `(let ((json-array-type 'list)
         (json-object-type 'plist)
         (json-key-type 'keyword)
         (json-false nil)
         (json-encoding-pretty-print nil))
     (,fn ,@args)
     )

  )

(defun ol-write-json-plists (metalist)
  "Work around json bug with lists of plists (METALIST)."
  (ol-jsonwrapper 
   (lambda ()
     (let ((result "["))
       (cl-loop for s in metalist
                do
                (setq result (concat result
                                     (json-encode-plist s) "," )))
       (concat result "]")))
   )
  )

;; this isn't necessary actually!
(defun ol-write-json-alists (metalist)
  "Work around json bug with lists of plists (METALIST)."
  (ol-jsonwrapper 
   (lambda ()
     (let ((result "["))
       (cl-loop for s in metalist
                do
                (setq result (concat result
                                     (json-encode-alist s) "," )))
       (concat result "]")))
   )
  )

#+end_src

#+RESULTS:
: ol-write-json-alists

** Read-lines: Belongs up with the utility functions

#+begin_src emacs-lisp
;; stolen from xah, http://ergoemacs.org/emacs/elisp_read_file_content.html
(defun org-lms~read-lines (filePath)
  "Return a list of lines of a file at filePath."
  (with-temp-buffer
    (insert-file-contents filePath)
    (split-string (buffer-string) "\n" t)))


#+end_src

** ACTION Reading keywords in org files
:PROPERTIES:
:ORG_LMS_COURSE: calmwater
:END:

From a discussion w/ john kitchin, Nicolas Goaziou, ando thers, how to as itwre "define" a new keyword without the elabotrate  apparatus of an org exporter. 

*TODO:* don't forget to actually start using this

- GETTER :: 

#+begin_src emacs-lisp :results code


  ;; john kitchin's version
  (defun org-lms-get-keyword (key)
    (org-element-map (org-element-parse-buffer) 'keyword
      (lambda (k)
        (when (string= key (org-element-property :key k))
          (org-element-property :value k))) 
      nil t))

  ;; nicolas g's version
  (defun org-lms-get-keyword (key)
    "Get value of keyword, whether or not it's been defined by org. 

  Look for a keyword statement of the form 
  ,#+KEYWORD: 

  and return either the last-declared value of the keyword, or the
  value of the current headline's property of the same name."

    (let ((case-fold-search t)
          (regexp (format "^[ \t]*#\\+%s:" key))
          (result nil))
      (org-with-point-at 1
        (while (re-search-forward regexp nil t)
          (let ((element (org-element-at-point)))
            (when (eq 'keyword (org-element-type element))
              (push (org-element-property :value element) result)))))
      (or (org-entry-get nil key) (car result)))
    )



  (defun org-lms-set-keyword (tag value)
    "Set filetag TAG to VALUE.
          If VALUE is nil, remove the filetag."
    (save-excursion
      (goto-char (point-min))
      (if (re-search-forward (format "#\\+%s:" tag) (point-max) 'end)
          ;; replace existing filetag
          (progn
            (beginning-of-line)
            (kill-line)
            (when value
              (insert (format "#+%s: %s" tag value))))
        ;; add new filetag
        (if (looking-at "^$") 		;empty line
            ;; at beginning of line
            (when value
              (insert (format "#+%s: %s" tag value)))
          ;; at end of some line, so add a new line
          (when value
            (insert (format "\n#+%s: %s" tag value)))))))
#+end_src

* Integration with Mail systems
I like to mail my marks back to my students.  These are the functions that manage that.  

** Attachments 

Make sure to get all the attachments.  I think that org-mime now takes care of this so it might be a good idea to refactor.  


#+begin_src emacs-lisp

;; stolen from gnorb, but renamed to avoid conflicts
(defun org-lms~attachment-list (&optional id)
  "Get a list of files (absolute filenames) attached to the
  current heading, or the heading indicated by optional argument ID."
  (when (featurep 'org-attach)
    (let* ((attach-dir (save-excursion
                         (when id
                (org-id-goto id))
                         (org-attach-dir t)))
           (files
            (mapcar
             (lambda (f)
               (expand-file-name f attach-dir))
             (org-attach-file-list attach-dir))))
      files)))

#+end_src

** ACTION Sending Subtrees
Huh, interesting. I have two versions of this code and no idea which of them is actually used where!! +In fact, it kind of looks like neither is being used.  Source of much confusion!!+

*UPDATE <2018-11-08 Thu>:* ~org-mime-lms-send-subtree-with-attachments~ is an obsolete function which has been replaced by ~org-lms-mime-org-subtree-htmlize~.  I'm too hcicken to delete it right now but should do so soon.  

#+begin_src emacs-lisp
;; temp fix for gh
(defun org-lms~mail-text-only ()
  "org-mime-subtree and HTMLize"
  (interactive)
  (org-mark-subtree)
  (save-excursion
    (org-mime-org-subtree-htmlize)
    (message-send-and-exit)
    )
  )

;; mail integration. Only tested with mu4e.
(defun org-lms~send-subtree-with-attachments ()
  "org-mime-subtree and HTMLize"
  (interactive)
  ;; (org-mark-subtree)
  (let ((attachments (org-lms~attachment-list)))
    (save-excursion
      (org-lms-mime-org-subtree-htmlize attachments))
    ))

;; defunkt
(defun org-lms-send-subtree-with-attachments ()
  "org-mime-subtree and HTMLize"
  (interactive)
  (org-mark-subtree)
  (let ((attachments (mwp-org-attachment-list))
        (subject  (mwp-org-get-parent-headline)))
    ;;(insert "Hello " (nth 4 org-heading-components) ",\n")
    (org-mime-subtree)
    (insert "\nBest,\nMP.\n")
    (message-goto-body)
    (insert "Hello,\n\nAttached are the comments from your assignment.\n\n")
    (insert "At this point I have marked all the papers I know about. If 
you have not received a grade for work that you have handed in,
 please contact me immediately and we can resolve the situation!.\n\n")
    ;; (message "subject is" )
    ;; (message subject)
    ;;(message-to)
    (org-mime-htmlize)
    ;; this comes from gnorb
    ;; I will reintroduce it if I want to reinstate questions.
    ;; (map-y-or-n-p
    ;;  ;; (lambda (a) (format "Attach %s to outgoing message? "
    ;;  ;;                    (file-name-nondirectory a)))
    ;; (lambda (a)
    ;;   (mml-attach-file a (mm-default-file-encoding a)
    ;;                    nil "attachment"))
    ;; attachments
    ;; '("file" "files" "attach"))
    ;; (message "Attachments: %s" attachments)
    (dolist (a attachments) (message "Attachment: %s" a) (mml-attach-file a (mm-default-file-encoding a) nil "attachment"))
    (message-goto-to)
    ))
#+end_src

#+RESULTS:
: org-lms-send-subtree-with-attachments

** ACTION Mail Multiple Trees

Once again, I've written multiple functions to do two very similar tasks. Need to refactor!!!

*UPDATE* Need to test the new code. Once that's done, can also test Canvas integration by simultaneously sending to canvas in ~org-lms-mail-all~ (which will have to be refactored).

#+begin_src emacs-lisp

;;; NOTE I may have broken this via SEND-ALL condition !!! 2018-11-08
(cl-defun org-lms-return-all-assignments (&optional (send-all nil) (also-mail nil) (post-to-lms t) )
  "By default mail all subtrees 'READY' to student recipients, unless SEND-ALL is non-nil.
In that case, send all marked 'READY' or 'TODO'."
  (interactive)
  (message "Mailing all READY subtrees to students")
  (let ((send-condition
         (if send-all
             `(or (string= (org-element-property :todo-keyword item) "READY")
                  (string= (org-element-property :todo-keyword item) "TODO") )
           `(string= (org-element-property :todo-keyword item) "READY")
           )))
    (org-map-entries 
     #'ol-send-just-one
      )
    
    ;; (org-element-map (org-element-parse-buffer) 'headline
;;       (lambda (item)
;;         ;; (print (nth 0 (org-element-property :todo-keyword item)))
;;         (when (string= (org-element-property :todo-keyword item) "READY") ;;  send-condition ;;
;;           (save-excursion
;;             (goto-char (1+ (org-element-property :contents-begin item)))
;;             (when also-mail  (save-excursion
;;                                ;;(org-lms-mime-org-subtree-htmlize )
;;                              (org-lms~send-subtree-with-attachments)
;;                              ;; (message-send-and-exit)
;; ))
;;             (when post-to-lms (org-lms-put-single-submission-from-headline))
;;             (org-todo "SENT")))))
    )
  (org-cycle-hide-drawers 'all))


(cl-defun ol-send-just-one (&optional (also-mail nil) (post-to-lms t))
  ;; (print (nth 0 (org-element-property :todo-keyword item)))
  (interactive)
  (when (string= (nth 2 (org-heading-components) ) "READY")
  (when also-mail  (save-excursion
                     ;;(org-lms-mime-org-subtree-htmlize )
                     (org-lms~send-subtree-with-attachments)
                     (sleep-for 2)
                     ;; (message-send-and-exit)
                     ))
  (when post-to-lms (org-lms-put-single-submission-from-headline))
  (org-todo "SENT")))
;; should get rid of this & just add a flag to ~org-lms-mail-all~
(defun org-lms-mail-all-undone ()
  (interactive)
  "Mail all subtrees marked 'TODO' to student recipients."
  (org-element-map (org-element-parse-buffer) 'headline
    (lambda (item)
      ;; (print (nth 0 (org-element-property :todo-keyword item)))
      (when (string= (org-element-property :todo-keyword item) "TODO")
        (save-excursion
          (goto-char (1+ (org-element-property :begin item)) )
          ;;(print "sending")
          ;;(print item)
          (save-excursion
            (org-lms-send-missing-subtree)
            (message-send-and-exit))
          (org-todo )
          ))
      )
    ))




;; doesn't seem to actually be used... 
(defun org-lms-send-missing-subtree ()
  "org-mime-subtree and HTMLize"
  (interactive)
  (org-mark-subtree)
  (let ((attachments (mwp-org-attachment-list))
        (subject  (mwp-org-get-parent-headline)))
    ;;(insert "Hello " (nth 4 org-heading-components) ",\n")
    (org-mime-subtree)
    (insert "\nBest,\nMP.\n")
    (message-goto-body)
    (insert "Hello,\n\nI have not received a paper from you, and ma sending this email just to let you know.\n\n")
    (insert "At this point I have marked all the papers I know about. If 
you have not received a grade for work that you have handed in,
 please contact me immediately and we can resolve the situation!.\n\n")
    (org-mime-htmlize)
    ;; this comes from gnorb
    ;; I will reintroduce it if I want to reinstate questions.
    ;; (map-y-or-n-p
    ;;  ;; (lambda (a) (format "Attach %s to outgoing message? "
    ;;  ;;                    (file-name-nondirectory a)))
    ;; (lambda (a)
    ;;   (mml-attach-file a (mm-default-file-encoding a)
    ;;                    nil "attachment"))
    ;; attachments
    ;; '("file" "files" "attach"))
    ;; (message "Attachments: %s" attachments)
    (dolist (a attachments) (message "Attachment: %s" a) (mml-attach-file a (mm-default-file-encoding a) nil "attachment"))
    (message-goto-to)
    ))


#+end_src

#+RESULTS:
: org-lms-send-missing-subtree



** Even more Mail -- org-mime rewrite functions. 

Actually *this* is the real real work... 

More mail-related functions -- rewwrite sof org-mime functions
i needed to modify stuff in the middle of the org-mime process, so I modified these fns lightly.

#+begin_src emacs-lisp

;; more helpers
(defun org-lms-mime-org-subtree-htmlize (&optional attachments)
  "Create an email buffer of the current subtree.
The buffer will contain both html and in org formats as mime
alternatives.

The following headline properties can determine the headers.\n* subtree heading
   :PROPERTIES:
   :MAIL_SUBJECT: mail title
   :MAIL_TO: person1@gmail.com
   :MAIL_CC: person2@gmail.com
   :MAIL_BCC: person3@gmail.com
   :END:

The cursor is left in the TO field."
  (interactive)
  (save-excursion
    ;; (funcall org-mime-up-subtree-heading)
    (cl-flet ((mp (p) (org-entry-get nil p org-mime-use-property-inheritance)))
      (let* ((file (buffer-file-name (current-buffer)))
             (subject (or (mp "MAIL_SUBJECT") (nth 4 (org-heading-components))))
             (to (mp "MAIL_TO"))
             (cc (mp "MAIL_CC"))
             (bcc (mp "MAIL_BCC"))
             (addressee (or (mp "NICKNAME") (mp "FIRSTNAME") ) )
             ;; Thanks to Matt Price for improving handling of cc & bcc headers
             (other-headers (cond
                             ((and cc bcc) `((cc . ,cc) (bcc . ,bcc)))
                             (cc `((cc . ,cc)))
                             (bcc `((bcc . ,bcc)))
                             (t nil)))
             (subtree-opts (when (fboundp 'org-export--get-subtree-options)
			     (org-export--get-subtree-options)))
	     (org-export-show-temporary-export-buffer nil)
	     (org-major-version (string-to-number
				 (car (split-string  (org-release) "\\."))))
	     (org-buf  (save-restriction
			   (org-narrow-to-subtree)
			   (let ((org-export-preserve-breaks org-mime-preserve-breaks)
                                 )
			     (cond
			      ((= 8 org-major-version)
			       (org-org-export-as-org
			        nil t nil
			        (or org-mime-export-options subtree-opts)))
			      ((= 9 org-major-version)
			       (org-org-export-as-org
			        nil t nil t
			        (or org-mime-export-options subtree-opts)))))))
	     (html-buf (save-restriction
			 (org-narrow-to-subtree)
			 (org-html-export-as-html
			  nil t nil t
			  (or org-mime-export-options subtree-opts))))
	     ;; I wrap these bodies in export blocks because in org-mime-compose
	     ;; they get exported again. This makes each block conditionally
	     ;; exposed depending on the backend.
	     (org-body (prog1
			   (with-current-buffer org-buf
			     ;; (format "#+BEGIN_EXPORT org\n%s\n#+END_EXPORT"
				   ;;   (buffer-string))
           (buffer-string))
			 (kill-buffer org-buf)))
	     (html-body (prog1
			    (with-current-buffer html-buf
			      (format "#+BEGIN_EXPORT html\n%s\n#+END_EXPORT"
				      (buffer-string))
            ;; (buffer-string)
            )
			  (kill-buffer html-buf)))
	     ;; (body (concat org-body "\n" html-body))
       (body org-body))
	(save-restriction
	  (org-narrow-to-subtree)
	  (org-lms-mime-compose body file to subject other-headers
			            (or org-mime-export-options subtree-opts)
                                    addressee))
        (if (eq org-mime-library 'mu4e)
        (advice-add 'mu4e~switch-back-to-mu4e-buffer :after
                    `(lambda ()
                       (switch-to-buffer (get-buffer ,(buffer-name) ))
                       (advice-remove 'mu4e~switch-back-to-mu4e-buffer "om-temp-advice"))
                    '((name . "om-temp-advice"))))
        (dolist (a attachments)  (mml-attach-file a (mm-default-file-encoding a) nil "attachment"))

	(message-goto-to)
        (message-send-and-exit)
        ))))

(defun org-lms-mime-compose (body file &optional to subject headers opts addressee)
  "Create mail BODY in FILE with TO, SUBJECT, HEADERS and OPTS."
  (when org-mime-debug (message "org-mime-compose called => %s %s" file opts))
  (setq body (format "Hello%s, \n\nAttached are the comments from your assignment.\n%s\nBest,\nMP.\n----------\n" (if addressee (concat " " addressee) "")  (replace-regexp-in-string "\\`\\(\\*\\)+.*$" "" body)))
  (let* ((fmt 'html)
	 ;; we don't want to convert org file links to html
	 (org-html-link-org-files-as-html nil)
	 ;; These are file links in the file that are not images.
	 (files
	  (if (fboundp 'org-element-map)
	      (org-element-map (org-element-parse-buffer) 'link
		(lambda (link)
		  (when (and (string= (org-element-property :type link) "file")
			     (not (string-match
				   (cdr (assoc "file" org-html-inline-image-rules))
				   (org-element-property :path link))))
		    (org-element-property :path link))))
	    (message "Warning: org-element-map is not available. File links will not be attached.")
	    '())))
    (unless (featurep 'message)
      (require 'message))
    (cl-case org-mime-library
      (mu4e
       (mu4e~compose-mail to subject headers nil))
      (t
       (message-mail to subject headers nil)))
    (message-goto-body)
    (cl-labels ((bhook (body fmt)
		       (let ((hook 'org-mime-pre-html-hook))
			 (if (> (eval `(length ,hook)) 0)
			     (with-temp-buffer
			       (insert body)
			       (goto-char (point-min))
			       (eval `(run-hooks ',hook))
			       (buffer-string))
			   body))))
      (let* ((org-link-file-path-type 'absolute)
	     (org-export-preserve-breaks org-mime-preserve-breaks)
	     (plain (org-mime--export-string body 'org))
	     ;; this makes the html self-containing.
	     (org-html-htmlize-output-type 'inline-css)
	     ;; this is an older variable that does not exist in org 9
	     (org-export-htmlize-output-type 'inline-css)
	     (html-and-images
	      (org-mime-replace-images
	       (org-mime--export-string (bhook body 'html) 'html opts)
	       file))
	     (images (cdr html-and-images))
	     (html (org-mime-apply-html-hook (car html-and-images))))
	;; If there are files that were attached, we should remove the links,
	;; and mark them as attachments. The links don't work in the html file.
	(mapc (lambda (f)
		(setq html (replace-regexp-in-string
			    (format "<a href=\"%s\">%s</a>"
				    (regexp-quote f) (regexp-quote f))
			    (format "%s (attached)" (file-name-nondirectory f))
			    html)))
	      files)
	(insert (org-mime-multipart plain html)
		(mapconcat 'identity images "\n"))
	;; Attach any residual files
	(mapc (lambda (f)
		(when org-mime-debug (message "attaching: %s" f))
		(mml-attach-file f))
	      files)))))
#+end_src

#+RESULTS:
: org-lms-mime-compose

#+begin_src emacs-lisp


#+end_src 

* Making headings
** Principal headline-making functions
~org-lms-make-headings~ used to be the main thing we did here. Now ther's a bunch more. 

#+begin_src emacs-lisp
;; MAIN ORG-LMS UTILITY FUNCTIONS

;; attaching files to subtrees
;; looks like this is unuesed.  
(defun org-lms-attach () 
  "Interactively attach a file to a subtree. 

Assumes that the parent headline is the name of a subdirectory,
and that the current headline is the name of a student. Speeds up file choice."
  (interactive)
  (let ((lms-att-dir
         (org-entry-get (point) "ORG_LMS_ASSIGNMENT_DIRECTORY" t)
         
         ;; (save-excursion
         ;;   (org-up-heading-safe)
         ;;   ())
         ))
    (message lms-att-dir)
    ;; (read-file-name
    ;;  (concat  "File for student " (nth 4 (org-heading-components)) ":")
    ;;  (expand-file-name lms-att-dir))
    (if lms-att-dir
        (org-attach-attach (read-file-name
                            (concat  "File for student " (nth 4 (org-heading-components)) ":")
                            (concat  (expand-file-name lms-att-dir) "/")))
      (message "Warning: no such directory %s; not attaching file" lms-att-dir))
    )
  ;; (if (save-excursion
  ;;       )
  ;;     (org-attach-attach (read-file-name
  ;;                         (concat  "File for student " (nth 4 (org-heading-components)) ":")
  ;;                         (org-lms~get-parent-headline) ))
  ;;   (message "Warning: no such directory %s; not attaching file" (org-lms~get-parent-headline)))
  )

(define-key org-attach-map (kbd "s p") #'projectile-pt)

(defun org-lms-make-headings (a students)
  "Create a set of headlines for grading.

A is a plist describing the assignment. STUDENTS is now assumed
to be a plist, usually generated by
`org-lms~parse-plist-csv-file' but eventually perhaps read
directly from Canvas LMS. UPDATE: seems to work well with
`org-lms-merged-students'

Canvas LMS allows for export of student information; the
resultant csv file has a certain shape, bu this may all be irrelevant now."
  (message "running org-lms-make-headings")
  (save-excursion
    (goto-char (point-max))
    ;; (message "students=%s" students)
    ;; (mapcar (lambda (x)))
    (let* ((body a)
           (atitle (plist-get body :name ))
           (assignmentid (or (format "%s" (plist-get body :canvasid)) ""))
           (directory (plist-get body :directory ))
           (weight (plist-get body :assignment-weight ))
           (grade-type (plist-get body :grade-type ))
           (assignment-type (plist-get body :assignment-type))
           (basecommit (or (plist-get body :basecommit) "none"))
           (repo-basename (or  (plist-get body :repo-basename) ""))
           (courseid (or (plist-get body :courseid) (org-lms-get-keyword "ORG_LMS_COURSEID")) 
                     ;; (if  (and  (boundp 'org-lms-course) (listp org-lms-course))
                     ;;     (number-to-string (plist-get org-lms-course :id))
                     ;;   nil)
                     )
           (template (plist-get body :rubric))
           ;; (template (let ((output ""))
           ;;             (dolist (item  (plist-get body :rubric-list) output)
           ;;               (setq output (concat output
           ;;                                    (format "- *%s* :: \n" item))))))
           ;; (template (plist-get 'rubric-list body))
           )
      ;; (message "BODY:\n%s\n%s\n%s\n%s/BODY" body atitle directory weight)
      ;; (message "DANVASID %s" assignmentid)
      ;; (message "car assignment successful: %s" template)
      (insert (format "\n* %s :ASSIGNMENT:" atitle))
      (org-set-property "ASSIGNMENTID" assignmentid)
      (org-set-property "ORG_LMS_ASSIGNMENT_DIRECTORY" directory)
      (org-set-property "BASECOMMIT" basecommit)
      (make-directory directory t)
      (goto-char (point-max))
      (let* (( afiles (if (file-exists-p directory)
                         (directory-files directory  nil ) nil))
            (json-array-type 'list)
            (json-object-type 'plist)
            (json-key-type 'keyword)
            (json-false nil)
            (prs (if (string= assignment-type "github") (json-read-file "./00-profile-pr.json"))))
        (mapcar (lambda (stu)
                  ;;(message "%s" stu)
                  (let* ((fname (plist-get stu :firstname))
                         (lname (plist-get stu :lastname))
                         (nname (or  (unless (equal  (plist-get stu :nickname) nil)
                                       (plist-get stu :nickname)) fname))
                         (email (plist-get stu :email))
                         (coursenum (if  (and  (boundp 'org-lms-course) (listp org-lms-course))
                                        (plist-get org-lms-course :coursenum)
                                      nil))

                         (github (or  (plist-get stu :github) ""))
                         (id (or (number-to-string (plist-get stu :id)) ""))
                         (props 
                          `(("GRADE" . "0")
                            ("CHITS" . "0")
                            ("NICKNAME" . ,nname)
                            ("FIRSTNAME" . ,fname)
                            ("LASTNAME" . ,lname)
                            ("MAIL_TO" . ,email)
                            ("GITHUB" . ,github)
                            ("ORG_LMS_REPO_BASENAME" . ,repo-basename)
                            ("STUDENTID" . ,id)
                            ("COURSEID" . ,courseid)
                            ("BASECOMMIT" . ,basecommit) ;; it would be better to keep this in the parent
                            ("ORG_LMS_ASSIGNMENT_DIRECTORY" . ,directory)
                            ;; ("MAIL_CC" . "matt.price@utoronto.ca")
                            ("MAIL_REPLY" . "matt.price@utoronto.ca")
                            ("MAIL_SUBJECT" .
                             ,(format "%sComments on Assignment \"%s\" (%s %s)"
                                      (if coursenum
                                          (format "[%s] " coursenum)
                                        "")
                                      atitle nname lname ))
                            ))
                         )
                    ;; (message "COURSENUM: %s" coursenum)
                    (insert (format "\n** %s %s\n" nname lname))
                    (org-todo 'todo) 
                    (dolist (p props)
                      (org-set-property (car p ) (cdr p)))
                    (insert (or template ""))
                    (if weight (insert (format "This assignment is worth *%s percent* of your mark and is graded as a letter grade. Please see ... for more details.\n"
                                               (* 100   (if (numberp weight) weight (string-to-number weight))))))


                    ;; TODO: this should be converted to a (cond...) that works differnetly
                    ;; with different assignment types
                    ;; try to attach files, if possible
                    ;; (message "SUBMISSIONTYPE %s" assignment-type)
                    (cond
                     ((equal assignment-type "github")
                      (org-set-property "LOCAL_REPO"
                                        (expand-file-name
                                         github
                                         ;; old way
                                         ;; (concat repo-basename "-" github)
                                         directory))
                      ;; this is some weird shit I used to do.  Time to fix it maybe.
                      ;; instead use a control vocabulary to find appropriate branches

                      ;; hard-coded!!!! 
                      (let* ((json-array-type 'list)
                             (json-object-type 'plist)
                             (json-key-type 'keyword)
                             (json-false nil)
                             (prs  '() ;; (json-read-file "./01-profile-pr.json")
                                  ))
                        ;; (message "MADE IT INTO LOOP for student with ID %s" github)
                        (if prs
                            ;; (message "%s" prs)
                            (dolist (pull prs) ;; need to update this I guless
                              ;; (message "%s: %s"github  pull)
                              
                                    (if (string= (plist-get pull :githubid) github)
                                        (progn
                                          (org-set-property "COMMENTS_PR" (plist-get pull :url))
                                          (let ((s (or (plist-get pull :status) "")))
                                            (org-set-property "TEST_STATUS" s)
                                            (cond
                                             ((string= "fail" s)
                                              (insert "\nYour repository did not pass all required tests."))
                                             ((string= "pass" s)
                                              (insert "\nYour repository passed all required tests for the basic asisgnment!"))
                                             ((string= "reflection" s)
                                              (insert "\nYour repository passed all tests, including the reflection checks!")))
                                            (insert (concat "\nThere may be further comments in your github repo: " (plist-get pull :url) )))
                                            ))
                                      ))
                          ))

                     ((equal assignment-type "canvas")
                      ;; (message "SUBTYPE IS CANVAS")
                      (org-lms-get-canvas-attachments))
                      (t
                      (let* ((fullnamefiles (remove-if-not (lambda (f) (string-match (concat "\\\(" fname "\\\)\\\([^[:alnum:]]\\\)*" lname) f)) afiles))
                             (nicknamefiles (remove-if-not (lambda (f) (string-match (concat "\\\(" nname "\\\)\\\([^[:alnum:]]\\\)*" lname) f)) afiles)))
                        ;;(message "fullnamefiles is: %s" fullnamefiles)
                        (if afiles
                            (cond
                             (fullnamefiles
                              ;; (if fullnamefiles)
                              (dolist (thisfile fullnamefiles)
                                ;;(message "value of thisfile is: %s" thisfile)
                                ;;(message "%s %s" (buffer-file-name) thisfile)
                                ;;(message "value being passed is: %s"(concat (file-name-directory (buffer-file-name)) assignment "/" thisfile) )
                                (org-attach-attach
                                 (concat (file-name-directory (buffer-file-name))
                                         directory "/" thisfile) )
                                (message "Attached perfect match for %s %s" fname lname)))
                             (nicknamefiles
                              (dolist (thisfile nicknamefiles)
                                ;; (if t)
                                ;; (progn) 
                                (org-attach-attach (concat (file-name-directory (buffer-file-name)) assignment "/" thisfile) )
                                (message "No perfect match; attached likely match for %s (%s) %s" fname nname lname)))

                             (t 
                              (message "No files match name of %s (%s) %s" fname nname lname)))
                          (message "warning: no directory %s, not attaching anything" directory)))
                      ;; other cases
                      )
                     )

                    ;; (condition-case nil

                    ;;   (error (message "Unable to attach file belonging to student %s" nname )))
                    (save-excursion
                      (org-back-to-heading)
                      ;;(org-mark-subtree);;

                      (org-cycle nil))
                    ))
                students)
        (run-hooks 'ol-make-headings-final-hook)
        )) 
    )
  (org-cycle-hide-drawers 'all))


#+end_src

#+RESULTS:
: org-lms-make-headings

** ACTION OBSOLETE github-specific function

#+begin_src emacs-lisp
;; org make headings, but for github assignments
(defun org-lms-make-headings-from-github (assignments students)
  "Create a set of headlines for grading.

ASSIGNMENTS is an alist in which the key is the assignment title,
and the value is itslef a plist with up to three elements. The
first is the assignment base name, the second is a list of files
to attach, and the third is the grading template. STUDENTS is now
assumed to be a plist, usually generated by
`org-lms~parse-plist-csv-file'. Relevant field in the plist are
First, Last, Nickname, Email, github.

The main innovations vis-a-vis `org-lms-make-headings` are
the structure of the the alist, and the means of attachment
"
  ;;(message "%s" assignments)
  (save-excursion
    (goto-char (point-max))
    (message "students=%s" students)
    (mapcar (lambda (x)
              (let* ((title (car x))
                     (v (cdr x))
                     (template (plist-get v :template))
                     (basename (plist-get v :basename))
                     (filestoget (plist-get v :files))
                     (prs (if (plist-get v :prs)
                              (org-lms~read-lines (plist-get v :prs))
                            nil))
                     )
                (insert (format "\n* %s :ASSIGNMENT:" title))
                ;;(let (( afiles (directory-files (concat title  )   nil ))))
                (mapcar (lambda (stu)
                          (let* ((fname (plist-get stu 'First))
                                 (lname (plist-get stu 'Last))
                                 (nname (or  (plist-get stu 'Nickname) fname))
                                 (email (plist-get stu 'Email))
                                 (github (plist-get stu 'github))
                                 (afiles (ignore-errors
                                           (directory-files
                                            (concat title "/" basename "-" github ))))
                                 
                                 )
                            (message "afiles is: %s" afiles )
                            ;;(message  "pliste gets:%s %s %s %s" fname lname nname email)
                            (insert (format "\n** %s %s" (if (string= nname "")
                                                          fname
                                                        nname) lname))
                            (org-todo 'todo)
                            (insert template)
                            (org-set-property "GRADE" "0")
                            (org-set-property "CHITS" "0")
                            (org-set-property "NICKNAME" nname)
                            (org-set-property "FIRSTNAME" fname)
                            (org-set-property "LASTNAME" lname)
                            (org-set-property "MAIL_TO" email)
                            (org-set-property "GITHUB" github)
                            (org-set-property "LOCAL_REPO" (concat title "/" basename "-" github "/" ))
                            (if prs
                                (mapcar (lambda (url)
                                          (message "inside lambda")
                                          (if (string-match github url)
                                              (progn
                                                (message "string matched")
                                                ;; one thought would be to add all comments PR's to this
                                                ;; but that would ocmplicate the logic for opening the PR URL
                                                ;; automatically
                                                ;; (org-set-property "COMMENTS_PR"
                                                ;;                   (concat (org-get-entry (point) "COMMENTS_PR") " " url))
                                                (org-set-property "COMMENTS_PR" url)
                                                (insert (concat "\nPlease see detailed comments in your github repo: " url))
                                                )))
                                        prs)
                              )
                            ;; (org-set-property "MAIL_CC" "matt.price@utoronto.ca")
                            (org-set-property "MAIL_REPLY" "matt.price@utoronto.ca")
                            (org-set-property "MAIL_SUBJECT"
                                              (format "Comments on %s Assignment (%s %s)"
                                                      (mwp-org-get-parent-headline) nname lname ))
                            
                            ;;   (error (message "Unable to attach file belonging to student %s" nname )))
                            (save-excursion
                              (org-mark-subtree)
                              (org-cycle nil))
                            ))students) ) ) assignments)))

#+end_src

* Set Grades and Overlays
These are for showing grades in the org buffer

#+begin_src emacs-lisp
;; still imperfect, but good enough for me.  
(defun org-lms-overlay-headings ()
  "Show grades at end of headlines that have a 'GRADE' property."
  (interactive)
  (require 'ov)

  (org-map-entries
   (lambda ()
     (when (org-entry-get (point) "GRADE")
       (ov-clear (- (line-end-position) 1)
                 (+ 0 (line-end-position)))
       (setq ov (make-overlay (- (line-end-position) 1)
                              (+ 0 (line-end-position))))
       (setq character (buffer-substring (- (line-end-position) 1) (line-end-position)))
       (overlay-put
        ov 'display
        (format  "%s  GRADE: %s CHITS: %s" character (org-entry-get (point) "GRADE") (org-entry-get (point) "CHITS")))
       (overlay-put ov 'name "grading")
       (message "%s" (overlay-get ov "name")))))
  )

(defun org-lms-clear-overlays ()
    "if the overlays become annoying at any point"
    (ov-clear)
    
    )

(defun org-lms-set-grade (grade)
  "set grade property at point and regenerate overlays"
  (interactive "sGrade:")
  (org-set-property "GRADE" grade)
  (org-lms-clear-overlays)
  (org-lms-overlay-headings) )


(defun org-lms-set-all-grades ()
  "set grade property for all headings on basis of \"- Grade :: \" line.

  Use with caution."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "- \\*?Grade\\*? :: \\(.+\\)" nil t )
      (org-set-property "GRADE" (match-string 1))
      ;; (save-excursion
      ;;   (org-back-to-heading)
      ;;   (org-set-property)
      ;;   (org-element-at-point))
      ))
  (org-lms-overlay-headings) 

  )

(defun org-lms-set-all-grades-boolean ()
  "set grade property for all headings on basis of \"- Grade :: \" line.

  Use with caution."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "- \\*?Grade\\* :: \\(.+\\)" nil t )
      (let ((grade (match-string 1)))
        (if (or (string-match "pass" (downcase grade)) (string-match "1" grade ))
            (progn (message grade)
                   (org-set-property "GRADE" "1"))
          )) 
      
      ;;(org-set-property "GRADE" (match-string 1))
      ;; (save-excursion
      ;;   (org-back-to-heading)
      ;;   (org-set-property)
      ;;   (org-element-at-point))
      ))
  (org-lms-overlay-headings) 
  ;;(org-lms-overlay-headings) 

  )

#+end_src

#+RESULTS:
: org-lms-set-all-grades-boolean

** More grading, for pass/fail 
These fuctions hould be up with the other grading stuff

#+begin_src emacs-lisp
;; helper function to set grades easily. Unfinished.
(defun org-lms-pass ()
  "set the current tree to pass"
  
  (interactive)
  (org-set-property "GRADE" "1")
  ;;(ov-clear)
  (org-lms-overlay-headings)
  )

(defun org-lms-chit ()
  "set the current tree to one chit"
  
  (interactive)
  (org-set-property "CHITS" "1")
  (ov-clear)
  (org-lms-overlay-headings)
  )

#+end_src

** Grade Report Tables
Generates a tables of marks for export to csv or direct manipulation within org. I don't find this that useful yet, needs some work. 
#+begin_src emacs-lisp
(defun org-lms-generate-tables ()
  "Generate a *grade report* buffer with a summary of the graded assignments
Simultaneously write results to results.csv in current directory."
  (interactive)

  (let ((students (org-lms-get-students))
        (assignments '()))

    ;; hack! having trouble with this
    (cl-loop for s in-ref students
             do (plist-put s :grades '()))
    ;;get assignments
    (let ((org-use-tag-inheritance nil))
      (org-map-entries
       (lambda ()
         (add-to-list 'assignments (nth 4 (org-heading-components)) t))
       "ASSIGNMENT"))
    
    ;;loop over entries
    ;; this should be improved, returning a plist to be looped over
    (dolist (assignment assignments)
      (save-excursion
        (org-open-link-from-string (format "[[%s]]" assignment)) ;; jump to assignment
        (org-map-entries        ;; map over entries
         (lambda ()
           (let* ((heading (nth 4 (org-heading-components)))
                  (email (org-entry-get (1+ (point)) "MAIL_TO" )))
             ;; loop over students, find the right one
             (cl-loop for s in-ref students
                      if (string= (plist-get s :email) email)
                      do
                      (let* ((grades (plist-get s :grades))
                             (g (org-entry-get (point) "GRADE")))
                        (cond
                         ((string= g "1") (setq g "Pass"))
                         ((string= g "0") (setq g "Fail")))
                        (add-to-list 'grades `(,assignment . ,g))
                        (add-to-list 'grades `(,(concat assignment " Chits") . ,(org-entry-get (point) "CHITS")))
                        (plist-put s :grades grades)))))
         nil 'tree)))
    ;; there's gotta be a bette way!
    (cl-loop for s in-ref students
             do (let ((grades (plist-get s :grades)))
               (plist-put s :grades (reverse grades))))
    (message "Students = %s" students)
    
    (let* ((columns (cl-loop for a in assignments
                                         collect a
                                         collect (concat a " Chits")))
           (tableheader (append '("Student" "First" "Nick" "Last" "Student #" "email") columns))
           (rows (cl-loop for s in students
                     collect
                     ;; (message "%s" s)
                     (let* ((grades (plist-get s :grades))
                            (row (append `(,(plist-get s :name)
                                           ,(plist-get s :firstname)
                                           ,(plist-get s :nickname)
                                           ,(plist-get s :lastname)
                                           ,(plist-get s :sis_user_id) ;; check to be sure this is right
                                           ,(plist-get s :email)
                                           )
                                         (cl-loop for c in columns
                                                  collect (cdr (assoc c grades))))))
                       (message "%s" row)
                       row)
                     )))
      (message "%s %s" (length rows) (length students)) (message "%s" tableheader)
      (cl-loop for h in-ref tableheader
               do
               (if (string-match "chits" (downcase h) )
                   (setq h "Chits")))
      
      (setq gradebook
            (append (list  tableheader
                           'hline)
                    rows))

      (write-region (orgtbl-to-csv gradebook nil) nil "results3.csv"))

    
    
    ;; I would like to put the gradebook IN the buffer but I can't figure out
    ;; a wayt odo it without killing 
    ;; (org-open-ling-from-string "[[#gradebook]]")
    ;;(let ((first-child (car (org-element-contents (org-element-at-point)))))  (when (eq )))
    (let ((this-buffer-name  (buffer-name)))
      (switch-to-buffer-other-window "*grade report*")
      (erase-buffer)
      (org-mode)
      
      (insert (orgtbl-to-orgtbl gradebook nil))
      (insert "\n\n* Grade reports\n")

      (cl-loop for s in students
               do
               (message "%s" s)
               (let* ((grades (plist-get s :grades))
                      (fname (plist-get s :firstname))
                      (lname (plist-get s :lastname))
                      (nname (or  (unless (equal  (plist-get s :nickname) nil)
                                    (plist-get s :nickname)) fname))
                      (email (plist-get s :email))
                      (coursenum (if  (and  (boundp 'org-lms-course) (listp org-lms-course))
                                     (plist-get org-lms-course :coursenum)
                                   ""))
                      (github (or  (plist-get s :github) ""))
                      ;; (id (or (number-to-string (plist-get s :id)) ""))
                      (props 
                       `(("NICKNAME" . ,nname)
                         ("FIRSTNAME" . ,fname)
                         ("LASTNAME" . ,lname)
                         ("MAIL_TO" . ,email)
                         ("GITHUB" . ,github)
                         ;; ("STUDENTID" . ,id)
                         ("MAIL_REPLY" . "matt.price@utoronto.ca")
                         ("MAIL_SUBJECT" .
                          ,(format "%s Grades Summary"
                                   (if coursenum
                                       (format "[%s] " coursenum)
                                     ""))))))
                 ;; (message "COURSENUM: %s" coursenum)
                 (insert (format "** TODO %s %s" nname lname))
                 ;; (org-todo 'todo)
                 (cl-loop for g in grades
                          do
                          (insert (concat "\n" "- " (car g) " :: " (cdr g) "\n"))
                          (dolist (p props)
                            (org-set-property (car p ) (cdr p))))
                 (save-excursion
                   (org-back-to-heading)
                   (org-cycle nil))
                 )
               )
      
      (pop-to-buffer this-buffer-name)))
  ;;(pop-to-buffer nil)
  )

;; try writing reports for each students
#+end_src

#+RESULTS:
: org-lms-generate-tables

* Github-related helper functions

#+begin_src emacs-lisp
;; helper functions for github repos
(defun org-lms~open-student-repo ()
  (interactive)
  (find-file-other-window (org-entry-get (point) "LOCAL_REPO" )))

(defun org-lms~open-attachment-or-repo () 
  (interactive)
  (let* ((attach-dir (org-attach-dir t))
         (files (org-attach-file-list attach-dir)))
    (if (> (length files) 0 )
        (org-attach-open)
      (org-lms~open-student-repo)
      )))

#+end_src

* Talking to Canvas  

These are the big new features of late 2018! Need to work on them quite a bit more.
** Basic "request" function
:PROPERTIES:
:GRADE:    1
:END:
These are basically wrappers around ~request.el~ that allow some of the requests to be simplified. I have written 2 functions, one for passing requests via header arguments, and another for passing them via json. THese should be combined & I should use a switch to allow users to use one interface rather than theo ther (though probably we should always go through the JSON interface!
) 
#+begin_src emacs-lisp
;; talking to canvas via API v1: https://canvas.instructure.com/doc/api/ 

(defun org-lms-canvas-request (query &optional request-type request-params file)
  "Send QUERY to `org-lms-baseurl' with http request type REQUEST-TYPE.
  Optionally send REQUEST-PARAMS as JSON data, and write results to FILE, which should be a full path.  

  Returns a user-error if `org-lms-token' is unset, or if data payload is nil. Otherwise return a parsed json data payload, with the following settings wrapping `json-read':

    `json-array-type' 'list
    `json-object-type' 'plist
    `json-key-type' 'symbol
    maybe key-type needs to be keyword though! Still a work in progress.
    "
  (unless request-type (setq request-type "GET"))
  (let ((canvas-payload nil)
        (canvas-err nil)
        (canvas-status nil)
        (json-params (json-encode request-params))
        (target (concat org-lms-baseurl query))
        ;; (request-coding-system 'no-conversion)
        ;; (request-conding-system 'no-conversion)
        )
    (message (concat target "   " request-type))
    ;; (message "%s" `(("Authorization" . ,(concat "Bearer " org-lms-token))))
    (message "PARAMS: %s" json-params)
    (if org-lms-token
        (progn (setq thisrequest
                     (request
                      target
                      
                      :type request-type
                      :headers `(("Authorization" . ,(concat "Bearer " org-lms-token))
                                 ("Content-Type" . "application/json")
                                 )
                      :sync t
                      :data   (if  json-params json-params  nil) ;; (or data nil)
                      :encoding 'no-conversion
                      :parser (lambda ()
                                (if (and (boundp 'file) file) (write-region (buffer-string) nil file))
                                (ol-jsonwrapper json-read))
                      :success (cl-function
                                (lambda (&key data &allow-other-keys)
                                  ;;(message "SUCCESS: %S" data)
                                  (message "SUCCESS!!")
                                  (setq canvas-payload data)
                                  canvas-payload
                                  ))
                      :error (cl-function (lambda ( &key error-thrown data status &allow-other-keys )
                                            (setq canvas-err error-thrown)
                                            (message "ERROR: %s" error-thrown)))))
               (unless (request-response-data thisrequest)                                   
                 (message (format "NO PAYLOAD: %s" canvas-err)) )
               (request-response-data thisrequest) )
      (user-error "Please set a value for for `org-lms-token' in order to complete API calls"))))
#+end_src

#+RESULTS:
: org-lms-canvas-request


** Doc: Functions to interact with specific parts of the Canvas API
This is a lot of the bulk of the library; these convenience functions make it easier to ask Canvas for specific, requently-requested kinds of information.

Organization:
- GETTERS :: for each supported endpoint, write a simple convenience function using ~org-lms-canvas-request~ to GET json data from endpoint
- SETTERS :: for each supported endpoint, write a simple convenience function using ~org=lms-canvas-request~ to POST or PUT json data to endpoint
- TRANSFORMERS :: where appropriate, write additional functions to translate canvas data into a form compatible with local data  

 Supported Endpoints

| Name    | Getter              | Setter | Transformer | API Reference |
|---------+---------------------+--------+-------------+---------------|
| courses | org-lms-get-courses | --     | --          |               |
|         |                     |        |             |               |

** STARTED Courses

- org-lms-get-courses :: getter for all courses
- org-lms-get-single-courses :: getter for single course with known id
- org-lms-infer-course :: transformer for single coures 

No setters! 
*TODO:* figure out how ~break~ statements work in lisp so I can stop the ~loop~ in ~org-lms-infer-course~ after I find the right course!
#+begin_src emacs-lisp

  (defun org-lms-get-courseids (&optional file)
    "Get list of JSON courses and produce a simplified list with just ids and names, for convenience.
  Optionally write JSON output to FILE."
    (let ((result (org-lms-get-courses file)))
      (cl-loop for course in result
               collect
               `(,(plist-get course :id) ,(format "#+ORG_LMS_COURSEID: %s" (plist-get course :id)) ,(plist-get course :name) ))))

  (defun org-lms-get-courses (&optional file)
    "Get full list of JSON courses, optionally writing to FILE."
    (org-lms-canvas-request "courses" "GET" `(("include" . "term")) (if file (expand-file-name file))))

  (defun org-lms-get-single-course (&optional courseid file)
    "Get the current Canvas JSON object representing the coures with id COURSEID."
(setq courseid (or courseid
                       (org-lms-get-keyword "ORG_LMS_COURSEID")
                       (plist-get org-lms-course)))
    (org-lms-canvas-request (format "courses/%s" courseid) "GET" nil file))

  (defun org-lms-infer-course (&optional course recordp)
    "Attempt to infer Canvas ID of a local COURSE and return that object.
    \(using the information we already have.\)
    Optionally RECORDP the keyword.
    But RECORDP isn't actually implemented yet and for some reason 
    this fn returns a course object not a ocursid!"
    (unless course
      (setq course org-lms-course))

    (let ((canvas-courses (org-lms-get-courses))
          (coursenum (plist-get course :coursenum))
          (shortname (plist-get course :shortname))
          (semester (plist-get course :semester))
          (result nil)
          )
      (loop for can in-ref canvas-courses
            do
            ;;(prin1 can)
            (let ((course-code (plist-get can :sis_course_id)))
              ;; (message "COURSECODE %s" course-code)
              (if (and
                   course-code
                   (string-match coursenum  course-code )
                   (string-match semester course-code))
                  (progn
                    (plist-put can :shortname
                               shortname)
                    (plist-put can :coursenum coursenum)
                    (plist-put can :semester semester)
                    (setq result can)
                    (org-lms-set-keyword "ORG_LMS_COURSE" (plist-get result :id))))))
      (or result
          (user-error "No course in Canvas matches definition of %s" course))))

#+end_src

#+RESULTS:
: org-lms-infer-course

*** tests
Implemented:
- org-lms-get-courses
- org-lms-get-courseids
- org-lms-get-single-course

TODO: 
- org-lms-infer-course
- 
#+begin_src emacs-lisp :tangle org-lms-tests.el :results code
     (ert-deftest org-lms-test-course-functions ()
     "tests the output of org-lms-get-courseids"
     (should (equal (org-lms-get-courses) '((:id 83085 :name "AODA Training Module 3" :account_id 303 :uuid "jKuVq1zF8L9OdRhW7S4wlPix7wYsEGihgxDh4b83" :start_at "2018-07-31T19:46:33Z" :grading_standard_id nil :is_public :json-false :created_at "2018-07-27T18:10:12Z" :course_code "HR-AODA-3" :default_view "wiki" :root_account_id 1 :enrollment_term_id 1 :end_at nil :public_syllabus :json-false :public_syllabus_to_auth :json-false :storage_quota_mb 3000 :is_public_to_auth_users :json-false :term
         (:id 1 :name "Default Term" :start_at nil :end_at nil :created_at "2017-10-20T17:47:47Z" :workflow_state "active" :grading_period_group_id nil)
         :apply_assignment_group_weights :json-false :calendar
         (:ics "https://q.utoronto.ca/feeds/calendars/course_jKuVq1zF8L9OdRhW7S4wlPix7wYsEGihgxDh4b83.ics")
         :time_zone "America/New_York" :blueprint :json-false :enrollments
         ((:type "student" :role "StudentEnrollment" :role_id 3 :user_id 84412 :enrollment_state "active"))
         :hide_final_grades t :workflow_state "available" :restrict_enrollments_to_course_dates :json-false)
    (:id 71671 :name "HIS393H1 S LEC0101 20191:Digital History" :account_id 70 :uuid "nslxGN7BH5RimQx70mvb4kike615qeXBqyqAp0jC" :start_at nil :grading_standard_id 15 :is_public t :created_at "2018-06-20T05:31:41Z" :course_code "HIS393H1 S LEC0101" :default_view "syllabus" :root_account_id 1 :enrollment_term_id 41 :end_at nil :public_syllabus :json-false :public_syllabus_to_auth :json-false :storage_quota_mb 3000 :is_public_to_auth_users :json-false :term
         (:id 41 :name "2019 Winter" :start_at nil :end_at "2020-04-30T04:00:00Z" :created_at "2018-06-20T05:30:22Z" :workflow_state "active" :grading_period_group_id nil)
         :apply_assignment_group_weights :json-false :calendar
         (:ics "https://q.utoronto.ca/feeds/calendars/course_nslxGN7BH5RimQx70mvb4kike615qeXBqyqAp0jC.ics")
         :time_zone "America/New_York" :blueprint :json-false :sis_course_id "HIS393H1-S-LEC0101-20191" :integration_id nil :enrollments
         ((:type "teacher" :role "TeacherEnrollment" :role_id 4 :user_id 84412 :enrollment_state "active"))
         :hide_final_grades t :workflow_state "unpublished" :restrict_enrollments_to_course_dates :json-false)
    (:id 35724 :name "Matthew Price's Sandbox" :account_id 3 :uuid "Ily3E2cFNsBQvhYzSdf6dpjYjY6uaTnXCAcEVjKV" :start_at nil :grading_standard_id nil :is_public nil :created_at "2017-12-06T21:59:44Z" :course_code "Matthew Price's Sandbox" :default_view "modules" :root_account_id 1 :enrollment_term_id 1 :end_at nil :public_syllabus :json-false :public_syllabus_to_auth :json-false :storage_quota_mb 3000 :is_public_to_auth_users :json-false :term
         (:id 1 :name "Default Term" :start_at nil :end_at nil :created_at "2017-10-20T17:47:47Z" :workflow_state "active" :grading_period_group_id nil)
         :apply_assignment_group_weights :json-false :calendar
         (:ics "https://q.utoronto.ca/feeds/calendars/course_Ily3E2cFNsBQvhYzSdf6dpjYjY6uaTnXCAcEVjKV.ics")
         :time_zone "America/New_York" :blueprint :json-false :sis_course_id "pricemat-sandbox" :integration_id nil :enrollments
         ((:type "teacher" :role "TeacherEnrollment" :role_id 4 :user_id 84412 :enrollment_state "active"))
         :hide_final_grades :json-false :workflow_state "unpublished" :restrict_enrollments_to_course_dates :json-false)
    (:id 64706 :name "NEW271H1 F LEC0201 20189:Interdisciplinary Special Topics" :account_id 85 :uuid "wTsoMexdJLKF3SURRtyR9f2QM42vHVh4UfK0g61N" :start_at nil :grading_standard_id 15 :is_public t :created_at "2018-05-25T05:31:01Z" :course_code "NEW271H1 F LEC0201" :default_view "wiki" :root_account_id 1 :enrollment_term_id 39 :end_at nil :public_syllabus t :public_syllabus_to_auth :json-false :storage_quota_mb 3000 :is_public_to_auth_users :json-false :term
         (:id 39 :name "2018 Fall" :start_at nil :end_at "2020-01-01T05:00:00Z" :created_at "2018-05-02T05:17:34Z" :workflow_state "active" :grading_period_group_id nil)
         :apply_assignment_group_weights :json-false :calendar
         (:ics "https://q.utoronto.ca/feeds/calendars/course_wTsoMexdJLKF3SURRtyR9f2QM42vHVh4UfK0g61N.ics")
         :time_zone "America/New_York" :blueprint :json-false :sis_course_id "NEW271H1-F-LEC0201-20189" :integration_id nil :enrollments
         ((:type "teacher" :role "TeacherEnrollment" :role_id 4 :user_id 84412 :enrollment_state "active"))
         :hide_final_grades t :workflow_state "available" :course_format "on_campus" :restrict_enrollments_to_course_dates :json-false))))
     (should (equal (org-lms-get-courseids) '((83085 "#+ORG_LMS_COURSEID: 83085" "AODA Training Module 3")
                                              (71671 "#+ORG_LMS_COURSEID: 71671" "HIS393H1 S LEC0101 20191:Digital History")
                                              (35724 "#+ORG_LMS_COURSEID: 35724" "Matthew Price's Sandbox")
                                              (64706 "#+ORG_LMS_COURSEID: 64706" "NEW271H1 F LEC0201 20189:Interdisciplinary Special Topics")) ))
     (should (equal (org-lms-get-single-course 83085) '(:id 83085 :name "AODA Training Module 3" :account_id 303 :uuid "jKuVq1zF8L9OdRhW7S4wlPix7wYsEGihgxDh4b83" :start_at "2018-07-31T19:46:33Z" :grading_standard_id nil :is_public :json-false :created_at "2018-07-27T18:10:12Z" :course_code "HR-AODA-3" :default_view "wiki" :root_account_id 1 :enrollment_term_id 1 :end_at nil :public_syllabus :json-false :public_syllabus_to_auth :json-false :storage_quota_mb 3000 :is_public_to_auth_users :json-false :apply_assignment_group_weights :json-false :calendar
     (:ics "https://q.utoronto.ca/feeds/calendars/course_jKuVq1zF8L9OdRhW7S4wlPix7wYsEGihgxDh4b83.ics")
     :time_zone "America/New_York" :blueprint :json-false :enrollments
     ((:type "student" :role "StudentEnrollment" :role_id 3 :user_id 84412 :enrollment_state "active"))
     :hide_final_grades t :workflow_state "available" :restrict_enrollments_to_course_dates :json-false))))
  (org-lms-get-courseids )
  (org-lms-get-single-course 83085)
     ;;(org-lms-get-courses)
#+end_src


** Post syllabus
The syllabus is posted as an attribute of the course element. See [[https://canvas.instructure.com/doc/api/courses.html#method.courses.update][the API docs for a little more info]].  +*DOES NOT SEEM TO BE WORKING ON MY UNIVERSITY'S SYSTEM RIGHT NOW, SEE [[https://community.canvaslms.com/message/126301-how-cna-i-tell-if-i-have-permisison-to-post-a-syllabus][my canvas community post]] for more details!*+ Fixed; when using 

#+begin_src emacs-lisp
(defun org-lms-post-syllabus (&optional courseid subtreep)
  "Post  syllabus to course"
  (interactive)
  (setq courseid (or courseid
                     (org-lms-get-keyword "ORG_LMS_COURSEID")
                     (plist-get org-lms-course :id)))
  ;; (cl-flet ((org-html--build-meta-info
  ;;              (lambda (&rest args) "")))
  ;;     ;; (prin1 (symbol-function  'org-html--build-meta-info))
  ;; )
  (let* ((org-export-with-toc nil)
         ;;(org-export-with-smart-quotes nil)
         (org-html-postamble nil)
         (org-html-preamble nil)
         (org-html-xml-declaration nil)
         (org-html-head-include-scripts nil)
         (org-html-head-include-default-style nil)
         (org-html-klipsify-src nil)
         (org-export-with-title nil)
         (atext (org-export-as 'html subtreep nil t))
         (is_public (or (org-lms-get-keyword "IS_PUBLIC") t))
         (license (or (org-lms-get-keyword "LICENSE") "cc_by_nc_sa"))
         (default_view (or (org-lms-get-keyword "DEFAULT_VIEW" )"syllabus"))
         (grading_standard_id (or (org-lms-get-keyword "GRADING_STANDARD_ID") 15 ))
         ;;(response (org-lms-get-single-course courseid))
         (data-structure `(("course" . (
                                         ("syllabus_body" . ,atext)
                                        ("is_public" . ,is_public)
                                        ("grading_standard_id" . ,grading_standard_id)
                                        ("license" . ,license)
                                        ("default_view" . ,default_view)
                                        ("license" . ,license)
                                        ))))
         (response (org-lms-canvas-request
                    (format  "courses/%s" courseid) "PUT" data-structure ))
         )
    (write-region (json-encode data-structure) nil "/home/matt/syl.json")
    ;;(setq response)
    (message "Response: %s" response)
    response
    ))

#+end_src

#+RESULTS:
: org-lms-post-syllabus

*** Tests
This will have to be a bit more clever -- need to add some context and "with temp buffer" stuff here I think.  

** Custom Gradebook Columns
:PROPERTIES:
:GRADE:    1
:END:
Exploring this as a way to store nicknames and github IDs.  Doesn't seem any easier than whay I already have, except that if I end up in the canvas interface I'll be able to see my data.

#+begin_src emacs-lisp
  (defun org-lms-post-gb-column (title &optional columnid position teachernotes courseid)
      (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
      (org-lms-canvas-request
       (format "courses/%s/custom_gradebook_columns%s" courseid (if columnid (concat "/" columnid) "")) (if columnid "PUT" "POST") 
       `(("column[title]" . ,title)
         ;;,(if position ("column[position]" . position))
         ;;,(if teachernotes ("column[teacher_ notes]" . teachernotes))
         ))
      )

  (defun org-lms-get-gb-column-data (columnid &optional courseid)
                          (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
                          (org-lms-canvas-request
                           (format "courses/%s/custom_gradebook_columns/%s/data" courseid columnid) "GET" nil 
                           )
                          )

  (defun org-lms-get-gb-columns ( &optional courseid)
    (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
    (org-lms-canvas-request
     (format "courses/%s/custom_gradebook_columns/" courseid) "GET" nil 
     )
    )


  (defun org-lms-post-gb-column-data ( data &optional courseid)
    "Post DATA to custom grading columns in the gradebook for COURSEID.
  Data should be a list of 3-cell alists, in which the values of `column_id',
  `user_id', and `example_content' are set for each entity."
    (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
    (org-lms-canvas-request
     (format "courses/%s/custom_gradebook_column_data" courseid ) "PUT" data 
     )
    )
#+end_src


#+RESULTS:
: org-lms-post-gb-column-data

** Students and Users
- org-lms-get-students :: get students in a course
- org-lms-get-all-users :: also get the non-student users in a course
- org-lms-get-single-user :: get just one user (usally as student with id)
- org-lms-merge-student-lists :: merge local and LMS student definitions 
#+begin_src emacs-lisp


(defun org-lms-get-students (&optional courseid)
    "Retrieve Canvas student data for course with id COUSEID"
    (let* ((courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID")))
;; (courseid (plist-get course :id))
           (result
            (org-lms-canvas-request (format "courses/%s/users" courseid) "GET"
                                    '(("enrollment_type" . ("student"))
                                      ("include" . ("email"))
                                      ("per_page" . 500 )))))
      ;;(message "RESULTS")
      ;;(with-temp-file "students-canvas.json" (insert result))
      (loop for student in-ref result
            do
            (if (string-match "," (plist-get student :sortable_name))
                (let ((namelist  (split-string (plist-get student :sortable_name) ", ")))
                  (plist-put student :lastname (car namelist) )
                  (plist-put student :firstname (cadr namelist)))))
      result))

  (defun org-lms-get-all-users (&optional courseid)
  "Retrieve all users from the course with id COURSEID."
  (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
    (org-lms-canvas-request (format "courses/%s/users" courseid) "GET" '(("per_page" . 500))))

  (defun org-lms-get-single-user (studentid &optional courseid)
    (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
    (org-lms-canvas-request (format "courses/%s/users/%s" courseid  studentid) "GET"))

  (defun org-lms-find-local-user (id)
    (let* ((result nil))
      (cl-loop for s in org-lms-merged-students
               if (equal id (number-to-string (plist-get s :id)))
               do
               (setq result s))
      result))
#+end_src


#+begin_src emacs-lisp
;; fix broken symbol not keyword assignment!!!
(defun org-lms-merge-student-lists (&optional local canvas)
  "Merge student lists, optionally explicity named as LOCAL and CANVAS."

  (unless local
    (setq local (org-lms-get-local-students))
    )
  (unless canvas
    (setq canvas (org-lms-get-students)))

  ;;(message "%s" local)
 (if local 
  (loop for c in-ref canvas
        do (let* ((defn c)
                  (email (plist-get defn :email)))
             (loop for l in-ref local
                   if (string=  email  (plist-get l :email))
                   do
                   (progn 
                     (plist-put defn :github (plist-get l :github))
                     (if (plist-get l :nickname)
                         (progn
                           (plist-put defn :nickname (plist-get l :nickname))
                           (plist-put defn :short_name (plist-get l :nickname))))
                     (unless (plist-get c :firstname)
                       (plist-put defn :firstname (plist-get l :firstname)))
                     (unless (plist-get c :lastname)
                       (plist-put defn :lastname (plist-get l :lastname)))
                     
                 )))))
  (with-temp-file "students-merged.json" (insert  (ol-write-json-plists canvas)))
  canvas)

#+end_src

#+RESULTS:
: org-lms-merge-student-lists

** STARTED Creating Pages

[[https://canvas.instructure.com/doc/api/pages.html][Canvas pages object documentation]]

Function to create and update pages, which might start to reduce reliance on external websites.  

#+begin_src emacs-lisp 
(defun org-lms-post-page ()
  "Extract page data from HEADLINE.
  HEADLINE is an org-element object."
  (interactive)

  (let* ((canvasid (org-entry-get nil "CANVASID"))
         (canvas-page-url (org-entry-get nil "CANVAS_PAGE_URL"))
         ;; (duedate (org-entry-get nil "DUE_AT"))
         (org-html-checkbox-type 'unicode )  ;; canvas stirps checkbox inputs
         ;; (pointspossible (if (org-entry-get nil "PAGE_WEIGHT") (* 100 (string-to-number (org-entry-get nil "PAGE_WEIGHT")))))
         (editing-roles  (or  (org-entry-get nil "CANVAS_EDITING_ROLES") "teachers"))
         (subtype (if (equal (org-entry-get nil "PAGE_TYPE") "canvas") "online_upload" "none"))
         ;;( (org-entry-get nil "DUE_AT"))
         (publish (org-entry-get nil "OL_PUBLISH")))
    ;; (message "canvas evals to %s" (if canvasid "SOMETHING " "NOTHING" ))
    ;;(prin1 canvasid)
    (let* ((org-export-with-tags nil)
           (page-params `(("wiki_page" .
                                 (("title" .  ,(nth 4 (org-heading-components)) )
                                  ("body" . ,(org-export-as 'html t nil t))
                                  ;; ("submission_types" . ,subtype)
                                  ;; ("grading_type" . ,gradingtype)
                                  ;; ("grading_standard_idcomment" . 458)
                                  ("editing_roles" . ,editing-roles)
                                  ;; ("points_possible" . ,(or pointspossible 10))
                                  ("published" . ,(if publish t nil) )))))

           (response
            (org-lms-canvas-request (format "courses/%s/pages%s"
                                            (org-lms-get-keyword "ORG_LMS_COURSEID");; (plist-get org-lms-course :id)
                                            (if canvas-page-url
                                                (format  "/%s" canvas-page-url) "")
                                            )
                                    (if canvas-page-url "PUT" "POST")
                                    page-params
                                    ))
           (response-data (or response nil))
           )
      ;; (message "HERE COMES THE PARAMS %s" (request-response-data response) )
      ;; (prin1 (assq-delete-all "page[description]" page-params))
      (if (plist-get response-data :url)
          (progn
            (message "received response-data")
            (org-set-property "CANVASID" (format "%s"(plist-get response-data :page_id)))
            (org-set-property "CANVAS_PAGE_URL" (format "%s"(plist-get response-data :url)))
            (org-set-property "PUBLISH" (format "%s"(plist-get response-data :published)))
            (org-set-property "CANVAS_HTML_URL" (format "%s"(plist-get response-data :html_url)))
            (org-set-property "CANVAS_EDITING_ROLES" (format "%s" (plist-get response-data :editing_roles)))
            ;; (org-set-property "SUBMISSIONS_DOWNLOAD_URL" (format "%s"(plist-get response-data :submissions_download_url)))
            ;; (org-set-property "GRADING_STANDARD_ID" (format "%s"(plist-get response-data :grading_standard_id)))
            ;; (org-set-property "CANVAS_SUBMISSION_TYPES" (format "%s"(plist-get response-data :submission_types)))
            ;; (org-set-property "GRADING_TYPE" (format "%s"(plist-get response-data :grading_type)))
            ;; (org-set-property "CANVASID" (format "%s"(plist-get response-data :id)))

            ) )
      ;; (message "PAGE_TYPE is canvas %s" (equal "canvas" (org-entry-get nil "PAGE_TYPE")))
      ;; (message "RESPONSE IS %s" response)
      (if (plist-get response-data :html_url)
          (browse-url (plist-get response-data :html_url)))
      response)))


#+end_src

#+RESULTS:

** ACTION Modules

[[https://community.canvaslms.com/docs/DOC-10735][modules]] are collections of content intended to structure a course into sections ([[https://canvas.instructure.com/doc/api/modules.html][see api docs]]).  They don't map all that well onto my course docs organization, and they're likely to be difficult to maintain.  It wil ltake a lot of work to do this properly, but probably want to start with 
- [ ] an *accessor* that downloads module(s) using the [[https://canvas.instructure.com/doc/api/modules.html#method.context_modules_api.index][list modules]] function, and iterate through the results to create a tree with module item attributes stored in subtree properties.
- [ ] a *translator* that captures the lms item at point and stores its attributes in an org-element object that can be pasted into an existing module.  

The UI for this is likely to be a bit finicky so maybe don't make a lot of decisions right now.  

** ACTION Calendar Events
Right now I have no way to generate calendar events & therefore put stuff into the "upcoming events' stream in Canvas.  [[https://canvas.instructure.com/doc/api/calendar_events.html][The API for Calendar Events is described here]]. It won't be easy for me to accommodate this mode of organization, unfortunately.  Probably won't happen for a while.   

** Assignments, Submissions, and Attachments
Assignments first.  
- org-lms-get-assignments :: getter for all assignments in a course
- org-lms-merge-assignment-values :: transformer to merge local and LMS definitions of an assignment
-  :: 
#+begin_src emacs-lisp
  (defun org-lms-get-assignments (&optional courseid)
    (unless courseid
      (setq courseid (org-lms-get-keyword "ORG_LMS_COURSEID")))

    (org-lms-canvas-request (format "courses/%s/assignments" courseid) "GET"))

  (defun org-lms-get-single-assignment (assignmentid &optional courseid)
    (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
    (org-lms-canvas-request (format "courses/%s/assignments/%s" courseid assignmentid) "GET"))



  (defun org-lms-merge-assignment-values (&optional local canvas)
    (unless local
      (setq local org-lms-local-assignments ))
    (unless canvas
      (setq canvas (org-lms-get-assignments)))
    (message "LOCALLLLL")
    ;; (prin1 local)
    ;; (prin1 canvas)
    (let ((result '()))
      (loop for l in-ref local
            do (let* ((defn (cdr l))
                      (name (plist-get defn :name)))
                 (message "LLLLLLLLL")
                 ;; (prin1 l)
                 ;; (prin1 (plist-get (cdr l) :name))
                 ;; (prin1 name)
                 (dolist (c canvas)
                   (message "CCCCCCCC")
                   ;;(message "Printing canvas defn of %s" (plist-get c :name))
                   ;;(prin1 c)
                   (if (equal
                        name  (plist-get c :name))
                       (progn
                         (message "MADE ITI N")
                         (plist-put defn :canvasid (plist-get c :id))
                         (plist-put defn :html_url (plist-get c :html_url))
                         (plist-put defn :submissions_download_url (plist-get c :submissions_download_url))
                         (message "DEFN")
                         (prin1 defn)

                         (add-to-list 'result `(,(car l) .  ,defn)))))))
      result))
#+end_src

#+RESULTS:
: org-lms-merge-assignment-values

Submissions
- org-lms-get-submissions: 
#+begin_src emacs-lisp
  (defun org-lms-get-submissions (&optional courseid)
    "get all submisisons in a COURSE (rarely used)."
    (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
    (org-lms-canvas-request (format "courses/%s/students/submissions" courseid) "GET"))

  (defun org-lms-get-assignment-submissions ( assignmentid &optional courseid)
    "Get all submisisons belonging to ASSIGNMENTID in optional COURSE."
  
    (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
    (org-lms-canvas-request
     (format "courses/%s/assignments/%s/submissions/" courseid assignmentid ) "GET"))

  (defun org-lms-get-single-submission (studentid assignmentid &optional courseid)
    "Retrieve a single sugmission from canvas.
  STUDENTID identifies the student, ASSIGNMENTID the assignment, and COURSEID the course."
    (setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
    (org-lms-canvas-request
     (format "courses/%s/assignments/%s/submissions/%s" courseid assignmentid studentid) "GET"))
#+end_src

Attachments. These functions are a little complicated because attachments are stored on AWS and there's a 3-step process for getting them. The PUTTER is a little easier. 
#+begin_src emacs-lisp
(defun org-lms-get-canvas-attachments ()
  (interactive) 
  (let* ((assid
          (save-excursion 
            (org-up-heading-safe)
            (org-entry-get (point) "ASSIGNMENTID")
            ))
         (studentid (or (org-entry-get (point) "STUDENTID") (org-entry-get (point) "ID")))
         (submission (org-lms-get-single-submission studentid assid))
         (student (org-lms-find-local-user studentid))
         )
    (message "Sumission: %s" submission)
    (cl-loop for attachment in (plist-get submission :attachments)
             do
             (let* ((downloadurl (plist-get attachment :url))
                    (filename
                     (format "%s%s_%s%s_%s_%s"
                             (downcase (plist-get student :lastname))
                             (downcase (plist-get student :firstname))
                             (if (plist-get submission :late)
                                 "late_" "")
                             studentid   (org-lms-safe-pget attachment :studentid)
                             (plist-get attachment :display_name)))
                    (f (request-response-data
                        (request
                         downloadurl
                         :sync t
                         :parser 'buffer-string ))))
               (message "attachment exists")
               ;;(prin1 f)
               ;;(message "STUDENT %s" (or (plist-get attachment :late) "NOPE"))
               (let ((coding-system-for-write 'binary))
                 (with-temp-file (expand-file-name
                                  filename
                                  (org-entry-get (point) "ORG_LMS_ASSIGNMENT_DIRECTORY"))
                   (set-buffer-multibyte nil)
                   (insert (string-as-multibyte f))
                   ;; (encode-coding-string contents 'utf-8 nil (current-buffer))
                   ))
               ;; (with-temp-file (expand-file-name
               ;;                  filename
               ;;                  (org-entry-get (point) "ORG_LMS_ASSIGNMENT_DIRECTORY"))
               ;;   (insert (string-as-multibyte f) ))
               (unwind-protect
                   (condition-case err
                       (org-attach-attach (expand-file-name
                                           filename
                                           (org-entry-get
                                            (point) "ORG_LMS_ASSIGNMENT_DIRECTORY")))
                     ('error (message "Caught exception while attaching %s: [%s]"filename err)))
                 (message "Cleaning up attach...")))))
  )
#+end_src

#+RESULTS:
: org-lms-get-canvas-attachments

** Reading and Writing Assignment Variables from files
Storing assignments as an intermediate lisp object allows me to avoid parsing an org buffer or making a json call before doing things like making headlines.

#+begin_src emacs-lisp :results code
  (defun org-lms-map-assignments (&optional file )
    "turn a buffer of assignment objects into a plist with relevant info enclosed."

    (let ((old-buffer (current-buffer)))
      (with-temp-buffer 
        (if file (insert-file-contents (expand-file-name file))
          (insert-buffer-substring-no-properties old-buffer))
        ;; (insert-file-contents file)
        (org-mode)
        (let* ((id (org-lms-get-keyword "ORG_LMS_COURSEID"))
               (results '())
               (org-use-tag-inheritance nil)
               )
         ;; (message "BUFFER STRING SHOULD BE: %s" (buffer-string))
          (setq results 
                (org-map-entries
                 (lambda ()
                   (let* ((rubric )
                          (name (nth 4 (org-heading-components)))
                          (a-symbol (intern (or (org-entry-get nil  "ORG_LMS_ANAME") 
                                                (replace-regexp-in-string "[ \n\t]" "" name)))))
                     (setq rubric  (car (org-map-entries
                                         (lambda ()
                                           (let ((e (org-element-at-point )))
                                             ;; in case at some point we would rather have thewhole element (scary)
                                             ;; (org-element-at-point)
                                             (buffer-substring-no-properties
                                              (org-element-property :contents-begin e)
                                              (-  (org-element-property :contents-end e) 1))
                                             )) "rubric" 'tree))  )
                     ;; hopefully nothing broeke here w/ additions <2018-11-16 Fri>
                     `(,a-symbol .  (:courseid ,id :canvasid ,(org-entry-get nil "CANVASID")
                                               :due-at ,(org-entry-get nil "DUE_AT") :html_url ,(org-entry-get nil "CANVAS_HTML_URL")
                                               :name ,(nth 4 (org-heading-components)  ) 
                                               :submission_type ,(or (org-entry-get nil "SUBMISSION_TYPE") "online_upload") 
                                               :published ,(org-entry-get nil "OL_PUBLISH")
                                               :submission_url ,(org-entry-get nil "CANVAS_SUBMISSION_URL")
                                               :basecommit ,(org-entry-get nil "BASECOMMIT")
                                               :grade_type "letter_grade" ;; oops fix this!
                                               :assignment-type ,(org-entry-get nil "ASSIGNMENT_TYPE")
                                               :directory ,(or (org-entry-get nil "OL_DIRECTORY")
                                                               (downcase
                                                                (replace-regexp-in-string "[\s]" "-" name )))
                                               :rubric ,rubric)))
                                               ) "assignment"))
          ;;(message "RESULT IS: %s" results)
          results))) )

  (defun org-lms-save-assignment-map (&optional file)
    "Map assignments and save el object to FILE, \"assignments.el\" by default."
    (interactive)
    (unless file (setq file (expand-file-name "assignments.el")))
    (let ((output (org-lms-map-assignments)))
      (with-temp-file (expand-file-name "assignments.el")

        (prin1 output (current-buffer))  )) )

(defun org-lms-read-assignment-map (&optional file)
  "Read assignments map from optional FILE, `assignments.el' by default."
  (unless file (setq file (expand-file-name "assignments.el")))
(with-temp-buffer
  (insert-file-contents (expand-file-name file))
  (cl-assert (eq (point) (point-min)))
  (read (current-buffer)))
)

#+end_src

** Creating Assignments

Functions to create announcements and assignments. Actually the crucial assignment code is still languishing in ~grading-template.org~. That's one of the reasons I made this org file - -to try to avoid that kind of junk!

#+begin_src emacs-lisp

;; assignments

(defun org-lms-create-assignment (assignment-data &optional courseid)
  "Create assignment in course."
(setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
  (org-lms-canvas-json-request (format  "courses/%s/assignments" courseid)
                          "POST"
                          assignment-data)
  )

#+end_src

#+begin_src emacs-lisp 
(defun org-lms-parse-assignment ()
  "Extract assignment data from HEADLINE.
  HEADLINE is an org-element object."
  (interactive)

  (let* ((canvasid (org-entry-get nil "CANVASID"))
         (duedate (org-entry-get nil "DUE_AT"))
         (org-html-checkbox-type 'unicode )  ;; canvas stirps checkbox inputs
         (pointspossible (if (org-entry-get nil "ASSIGNMENT_WEIGHT") (* 100 (string-to-number (org-entry-get nil "ASSIGNMENT_WEIGHT")))))
         (gradingtype (or  (org-entry-get nil "GRADING_TYPE") "letter_grade"))
         (subtype (if (equal (org-entry-get nil "ASSIGNMENT_TYPE") "canvas") "online_upload" "none"))
         ;;( (org-entry-get nil "DUE_AT"))
         (publish (org-entry-get nil "OL_PUBLISH")))
    ;; (message "canvas evals to %s" (if canvasid "SOMETHING " "NOTHING" ))
    ;;(prin1 canvasid)
    (let* ((org-export-with-tags nil)
           (assignment-params `(("assignment" .
                                 (("name" .  ,(nth 4 (org-heading-components)) )
                                  ("description" . ,(org-export-as 'html t nil t))
                                  ,(if duedate
                                       `("due_at"   . ,(concat duedate  "T23:59:59-05:00")))
                                  ("submission_types" . ,subtype)
                                  ("grading_type" . ,gradingtype)
                                  ("grading_standard_idcomment" . 458)
                                  ("points_possible" . ,(or pointspossible 10))
                                  ("published" . ,(if publish t nil) )))))

           (response
            (org-lms-canvas-request (format "courses/%s/assignments%s"
                                            (org-lms-get-keyword "ORG_LMS_COURSEID");; (plist-get org-lms-course :id)
                                            (if canvasid
                                                (format  "/%s" canvasid) "")
                                            )
                                    (if canvasid "PUT" "POST")
                                    assignment-params
                                    ))
           (response-data (or response nil))
           )
      ;; (message "HERE COMES THE PARAMS %s" (request-response-data response) )
      ;; (prin1 (assq-delete-all "assignment[description]" assignment-params))
      (if (plist-get response-data :id)
          (progn
            (message "received response-data")
            (org-set-property "CANVASID" (format "%s"(plist-get response-data :id)))
            (org-set-property "PUBLISH" (format "%s"(plist-get response-data :published)))
            (org-set-property "CANVAS_HTML_URL" (format "%s"(plist-get response-data :html_url)))
            (org-set-property "CANVAS_SUBMISSION_URL" (format "%s" (plist-get response-data :submissions_download_url)))
            (org-set-property "SUBMISSIONS_DOWNLOAD_URL" (format "%s"(plist-get response-data :submissions_download_url)))
            (org-set-property "GRADING_STANDARD_ID" (format "%s"(plist-get response-data :grading_standard_id)))
            (org-set-property "CANVAS_SUBMISSION_TYPES" (format "%s"(plist-get response-data :submission_types)))
            (org-set-property "GRADING_TYPE" (format "%s"(plist-get response-data :grading_type)))
            (org-set-property "CANVASID" (format "%s"(plist-get response-data :id)))

            ) )
      ;; (message "ASSIGNMENT_TYPE is canvas %s" (equal "canvas" (org-entry-get nil "ASSIGNMENT_TYPE")))
      ;; (message "RESPONSE IS %s" response)
      response)))



(defun org-lms-post-assignment-and-save (&optional file)
  "First post the assignment, then save the value to FILE."
  (interactive)
  (unless file (setq file (expand-file-name "assignments.el")))
  (org-lms-parse-assignment)
  (org-lms-save-assignment-map file))
#+end_src

#+RESULTS:

** Marking and Returning Submissions
Sorta belongs with submissions above, but am trying to separate out stuff that is specific to my workflow (as opposed to just part of the Canvas API).
#+begin_src emacs-lisp

(defun org-lms-put-single-submission-from-headline (&optional studentid assignmentid courseid)
  "Get comments from student headline and post to Canvas LMS.
If STUDENTID, ASSIGNMENTID and COURSEID are omitted, their values
will be extracted from the current environment. Note the
commented out `dolist' macro, which will upload attachments to
canvas. THis process is potentially buggy and seems likely to
lead to race conditions and duplicated uploads and comments. Still
working on this."
  (interactive)
  ;;(setq courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
  (unless assignmentid
    (setq assignmentid (save-excursion (org-up-heading-safe)
                                       (org-entry-get (point) "ASSIGNMENTID"))))
  (unless studentid (setq studentid (org-entry-get (point)  "STUDENTID")))
  ;; main loop
  (let* ((courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID") (plist-get org-lms-course)))
         (grade (org-entry-get (point) "GRADE"))
         (comments (let*((org-export-with-toc nil)
                         ;;(atext (org-export-as 'html t))
                         (atitle (nth 4 (org-heading-components)))
                         (org-ascii-text-width 2305843009213693951))
                     (org-export-as 'ascii t nil t)))
         (returnval '()))
    ;; loop over attachments
    (dolist (a (org-attach-file-list (org-attach-dir t)))
      (let* ((path (expand-file-name a (org-attach-dir t) ))
             (fileinfo (org-lms-canvas-request
                        (format "courses/%s/assignments/%s/submissions/%s/comments/files"
                                courseid assignmentid studentid)
                        "POST" `(("name" . ,a)) ) ;; (request-response-data )
                       )
             (al (org-lms-plist-to-alist (plist-get fileinfo :upload_params)))
             (formstring ""))
        (cl-loop for prop in al
                 do
                 (setq formstring (concat formstring "-F '" (symbol-name (car prop))
                                          "=" (format "%s" (cdr prop)) "' ")))
        (setq formstring (concat formstring " -F 'file=@" path "' 2> /dev/null"))
        (let* ((thiscommand  (concat "curl '"
                                     (plist-get fileinfo :upload_url)
                                     "' " formstring))
               (curlres  (shell-command-to-string thiscommand))
               (file_id (if (> (length curlres) 0 ) (format "%s" (plist-get (ol-jsonwrapper json-read-from-string curlres) :id )))))
          (message "CURLRES: %s" curlres)
          
          (if file_id (progn
                        (setq returnval (add-to-list 'returnval file_id))
                        ;; this needs to be fixed up still -- only saves last
                        (org-entry-put (point) "ORG_LMS_ATTACHMENT_URL"
                                       file_id))))))
    (let* ((grade-params `(("submission" . (("posted_grade" . ,grade)))
                           ("comment" . (("text_comment" . ,comments)
                                         ;; EDIT 2018=11-07 -- untested switch from alist to plist
                                         ("file_ids" . ,returnval)
                                         ;; alas, doesn't seem to update the previous comment! drat
                                         ("id" . (or (org-entry-get nil "OL_COMMENT_ID" ) nil)))) ))
           (comment-response ;;(request-response-data)
            (org-lms-canvas-request
             (format "courses/%s/assignments/%s/submissions/%s" courseid assignmentid studentid)
             "PUT" grade-params)))
      (org-entry-put nil "ORG_LMS_SPEEDGRADER_URL"
                     (format
                      "[[https://q.utoronto.ca/courses/%s/gradebook/speed_grader?assignment_id=%s#{\"student_id\":%s}]]"
                      courseid assignmentid studentid))
      (org-entry-put nil "OL_COMMENT_ID"
                     (format "%s"
                             (plist-get  (car (plist-get comment-response
                                                         :submission_comments)) :id))  )
      (message "%s" (plist-get  (car (plist-get comment-response
                                                :submission_comments)) :id))
      (message "NO PROBLEMS HERE")
      ;; (message "Response: %s" comment-response )
      comment-response)))
#+end_src

#+RESULTS:
: org-lms-put-single-submission-from-headline

** ACTION Announcements
todo: docstrings!!
#+begin_src emacs-lisp
  ;; huh is this deprecated? 
(defun org-lms-post-announcement (payload &optional courseid)
  "Create new announcement using PAYLOAD a data in course COURSEID."
    (setq courseid (or courseid
                       (org-lms-get-keyword "ORG_LMS_COURSEID")
                       (plist-get org-lms-course)))
    (org-lms-canvas-request
     (format "courses/%s/discussion_topics" courseid) "POST" payload))

;; announcements

(defun org-lms-headline-to-announcement (&optional courseid file)
  ""
  (interactive)
  (setq courseid (or courseid
                       (org-lms-get-keyword "ORG_LMS_COURSEID")
                       (plist-get org-lms-course)))
  ;; (cl-flet ((org-html--build-meta-info
  ;;            (lambda (&rest args) ""))))
  (let* ((org-export-with-toc nil)
         (org-export-with-smart-quotes nil)
         (org-html-postamble nil)
         (org-html-preamble nil)
         (org-html-xml-declaration nil)
         (org-html-head-include-scripts nil)
         (org-html-head-include-default-style nil)
         ;;(atext (org-export-as 'html t))
         (atitle (nth 4 (org-heading-components)))
         (org-html-klipsify-src nil)
         (org-export-with-title nil)
         ;;(courseid (plist-get course :id))
         (atitle (nth 4 (org-heading-components)))
         (atext (org-export-as 'html t nil t))
         (response nil)
         (oldid (org-entry-get (point) "ORG_LMS_ANNOUNCEMENT_ID"))
         )
    ;; (message "BUILDMETA DEFN")
    ;; (prin1 (symbol-function  'org-html--build-meta-info))
    ;; (message "%s" atext)
    (if oldid
        (progn
          (message "already added!")
          (setq response ;;(request-response-data) 
                (org-lms-canvas-request
                 (format  "courses/%s/discussion_topics/%s" courseid oldid) "PUT"
                 `(("title" . ,atitle)
                   ("message" . ,atext)
                   ("is_published" . t)
                   ("is_announcement" . t)))))

      (setq response ;;(request-response-data)
            (org-lms-canvas-request
             (format  "courses/%s/discussion_topics" courseid) "POST"
             `(("title" . ,atitle)
               ("message" . ,atext)
               ("is_published" . t)
               ("is_announcement" . t)))))
    (cl-loop for (k v) on response
             do
             (message "%s %S" k v))
    (org-entry-put (point) "ORG_LMS_ANNOUNCEMENT_ID" (format "%s" (plist-get response :id)))
    (org-entry-put (point) "ORG_LMS_ANNOUNCEMENT_URL" (format "%s" (plist-get response :url)))
    (org-entry-put (point) "ORG_LMS_POSTED_AT" (format "%s" (plist-get response :posted_at)))

    (if (plist-get response :url) 
        (browse-url (plist-get response :url)))
    response))



#+end_src

#+RESULTS:
: org-lms-headline-to-announcement


*** troubleshooting
#+begin_src emacs-lisp :tangle no

  ;;; Code:

  ;; something else


  (json-encode '(("assignment[description]" . "<p>\nThis kind of amazing-sounding talk is happenin...") ("assignment[submission_types]" . "none") ("assignment[grading_type]" . "letter_grade") ))


  (json-encode `(("assignment[description]" . "<p>\nThis kind of amazing-sounding talk is happenin...") ("assignment[submission_types]" . "none") ("assignment[grading_type]" . "letter_grade")(descrpition . "" ) (key1 . "value1") ,(if nil t '("" . ""))))


#+end_src

to#+RESULTS:
: {"assignment[description]":"<p>\nThis kind of amazing-sounding talk is happenin...","assignment[submission_types]":"none","assignment[grading_type]":"letter_grade","descrpition":"","key1":"value1","":""}

** Grading Standards
Unfortunately, at Canadian schools we need to set the grading standard for every single assignment :frowning:  TThis should be another keyword I guess :-(. However... once again I don't seem to have permission to set the grading standards fro mthe API :-(; and I can't evne seme to *get* them, which is frustrating.    

#+begin_src emacs-lisp
(defun org-lms-get-grading-standards (&optional courseid)
    "Retrieve Canvas grading standards for course with id COUSEID"
    (let* ((courseid (or courseid (org-lms-get-keyword "ORG_LMS_COURSEID")))
           (result
            (org-lms-canvas-request (format "courses/%s/grading_standards" courseid) "GET" )))
      result))
#+end_src

#+RESULTS:
: org-lms-get-grading-standards

** Debugging
#+begin_src emacs-lisp
  (defun org-lms-inspect-object (method url headers)
      (restclient-http-do method url headers
       ))

#+end_src

#+begin_src emacs-lisp

#+end_src

** Canvas-inspect

I don't use this but the idea is that I'm supposed to be able to lok at the output of a request in a file. 

#+begin_src emacs-lisp
(defun org-lms-canvas-inspect (query &optional request-type request-params)
  "Send QUERY to `org-lms-baseurl' with http request type `type', using `org-lms-token' to authenticate.

Return an error if `org-lms-oauth' is unset. Otherwise return a list whose car is a parsed json
payload and whose cdr is an error message. The data payload will be a list, produced by `json-read' 
with thefollowing settings:

`json-array-type' 'list
`json-object-type' 'plist
`json-key-type' 'symbol

maybe key-type needs to be keyword though! Still a work in progress.
"
  (unless request-type
    (setq request-type "GET"))
  (let ((canvas-payload nil)
        (canvas-err nil)
        (canvas-status nil)

        )
    ;; (message (concat org-lms-baseurl query))
    ;; (message (concat "Bearer " org-lms-token))
    ;; (message "%s" `(("Authorization" . ,(concat "Bearer " org-lms-token))))
    (if org-lms-token
        (progn
          (setq thisrequest
                (request
                 (concat org-lms-baseurl query)
                 :type request-type
                 :headers `(("Authorization" . ,(concat "Bearer " org-lms-token)))
                 :sync t
                 :data (if  request-params request-params nil)
                 :parser 'buffer-string
                 :success (cl-function
                           (lambda (&key data &allow-other-keys)
                             (setq canvas-payload data)
                             (when data
                               (with-current-buffer (get-buffer-create "*request demo*")
                                 (erase-buffer)
                                 (insert data)
                                 (pop-to-buffer (current-buffer))
                                 (json-mode)
                                 (json-mode-beautify))))
                           )
                 :error (cl-function (lambda (&rest args  &key error-thrown &allow-other-keys)
                                       (setq canvas-err error-thrown)
                                       (message "ERROR: %s" error-thrown)))
                 ))
          ;; (message "pPAYLOAD: %s" canvas-payload)
          (if (request-response-data thisrequest)
              canvas-payload
            (error (format "NO PAYLOAD: %s" canvas-err)))
          ) 
      (user-error "Please set a value for for `org-lms-token' in order to complete API calls"))))
#+end_src

** Assignments Table

This function prints out a helpful table with links to various locations (e.g., LMS URLs for assignments & submissions) and elisp functions (e.g., grading headline generation).
#+begin_src emacs-lisp
  (defun org-lms-assignments-table (&optional assignments students)
    "Return a 2-dimensional list suitable whose contents are org-mode table cells.

  Intnded to be used in a simpe src block with :results header `value raw table'. 
  Resultant links allow quick access to the canvas web interface as well as the make-headings
  commangs."
    (unless assignments
      (setq assignments org-lms-merged-assignments))
    (unless students
      (setq students org-lms-merged-students))
    ;;(message "MERGED ASSIGNMENTS")
    ;;(prin1 assignments)
    (let* ((cid (org-lms-get-keyword "ORG_LMS_COURSEID"))
           (make-headlines-string "")
           (table-header '(("Name (upload here)" "Download URL" Inspect "Make Headers") hline))
           )
      (append '(("Name (upload here)" "Download URL" Inspect "Make Headers") hline)
              (cl-loop for i in assignments
                       collect `( ,(format "%s"
                                           (if (plist-get (cdr i) :html_url)
                                               (concat "[[" (org-lms-safe-pget (cdr i) :html_url) "][" (org-lms-safe-pget (cdr i) :name) "]]")
                                             (org-lms-safe-pget (cdr i) :name)) ) 
                                  ,(format "%s"
                                           (if (plist-get (cdr i) :submissions_download_url)
                                               (concat "[[" (org-lms-safe-pget (cdr i) :submissions_download_url) "][Download Submissions]]")
                                             " ")
                                           )
                                  ,(format
                                    "%s"
                                    (if (plist-get (cdr i) :canvasid)
                                        (concat  "[[elisp:(org-lms-canvas-inspect \"courses/"
                                                 (format "%s" cid)
                                                 "/assignments/"
                                                 (format "%s" (org-lms-safe-pget (cdr i) :canvasid))
                                                 "\")][Inspect Original JSON]]")
                                      " "))
                                  ;; "Inspect Original JSON"
                                  ,(format "[[%s][%s]]"
                                           (concat "elisp:(org-lms-make-headings (alist-get '"
                                                   (symbol-name (car i))
                                                   " org-lms-merged-assignments) org-lms-merged-students)"
                                                   ) 
                                           "Make Headlines"))))

      ))

#+end_src

#+RESULTS:
: org-lms-assignments-table

** ACTION Set up local environment
org-lms-setup especially is useful here; and "get-local-students" parses ~students.csv~ (kinda on its way to being deprecated eventually). 

*TODO*: Need to switch to JSON format for students!!

#+begin_src emacs-lisp
;;deprectaed!!!!!!
(defun org-lms-setup ()
  "Merge  defs and students lists, and create table for later use.

`org-lms-course', `org-lms-local-assignments' and other org-lms
variables must be set or errors wil lresult."
  (setq org-lms-merged-students (org-lms-merge-student-lists))
  (setq org-lms-merged-assignments (org-lms-merge-assignment-values))
  (org-lms-assignments-table org-lms-merged-assignments)
  )

(defun org-lms-setup-grading (&optional courseid assignmentsfile)
  "Parse assignments buffer and students lists, and create table for later use.

`org-lms-course', `org-lms-local-assignments' and other org-lms
variables must be set or errors will result."
  (setq org-lms-merged-students (org-lms-merge-student-lists))
  ;;(setq org-lms-merged-assignments (org-lms-merge-assignment-values))
  (setq assignments (org-lms-map-assignments (org-lms-get-keyword "ORG_LMS_ASSIGNMENTS")))
  (setq org-lms-merged-assignments assignments)
  (org-lms-assignments-table assignments)
  )
(defun org-lms-get-local-csv-students (&optional csv)
  (unless csv
    (setq csv "./students.csv"))
  (org-lms~parse-plist-symbol-csv-file csv)
  )

(defun org-lms-get-local-json-students (&optional jfile)
  (unless jfile
    (setq jfile "./students-local.json"))
  (ol-jsonwrapper json-read-file jfile))



(defcustom org-lms-get-student-function 'org-lms-get-local-json-students
  "function to use to get students"
  :type 'function)

(defun org-lms-get-local-students (&optional file)
  ;; (unless file
  ;;   (setq file "./students.json"))
  (apply org-lms-get-student-function (list file)))
#+end_src

#+RESULTS:
: org-lms-get-local-students

* Moribund minor-mode
It would be nice to define a minor mode that set the coure up properly, but there's a bit of a ways to go before I do that .

#+begin_src emacs-lisp
;; Minor mode definition. I'm not really using it right now, but it
;; might be a worthwhile improvement. 
(define-minor-mode org-lms-mode
  "a mode to get my grading in order"
  ;;:keymap (kbd "C-c C-x C-g" . (call-interactively (org-set-property "GRADE")))
  :lighter " Mark"
  )
#+end_src

* library closing

#+begin_src emacs-lisp
(provide 'org-lms)
;;; org-lms ends here
#+end_src
